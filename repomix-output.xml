This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.env.example
.gitignore
claudible-stealth-bypass.md
docs/deployment-guide.md
package.json
plans/260215-0133-smart-chatbot-rag/phase-01-setup-environment.md
plans/260215-0133-smart-chatbot-rag/phase-02-backend-api.md
plans/260215-0133-smart-chatbot-rag/phase-03-database-rag.md
plans/260215-0133-smart-chatbot-rag/phase-04-shopify-integration.md
plans/260215-0133-smart-chatbot-rag/phase-05-chat-widget.md
plans/260215-0133-smart-chatbot-rag/phase-06-ai-agent-logic.md
plans/260215-0133-smart-chatbot-rag/phase-07-testing-deployment.md
plans/260215-0133-smart-chatbot-rag/plan.md
src/config/env.ts
src/config/system-prompts.ts
src/db/schema.sql
src/db/supabase-client.ts
src/index.ts
src/routes/chat-routes.ts
src/routes/health-routes.ts
src/services/agent-tools.ts
src/services/chat-agent.ts
src/services/claudible-client.ts
src/services/embeddings-service.ts
src/services/rag-service.ts
src/services/shopify-admin-client.ts
src/services/shopify-factory.ts
src/services/shopify-storefront-client.ts
src/services/tenant-service.ts
src/types/index.ts
tsconfig.json
widget/index.html
widget/package.json
widget/public/embed.js
widget/src/app.tsx
widget/src/components/cart-button.tsx
widget/src/components/chat-bubble.tsx
widget/src/components/chat-input.tsx
widget/src/components/chat-messages.tsx
widget/src/components/product-card.tsx
widget/src/hooks/use-chat.ts
widget/src/hooks/use-sse.ts
widget/src/main.tsx
widget/src/styles.css
widget/src/types.ts
widget/tsconfig.json
widget/vite.config.ts
wrangler.toml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".env.example">
# Environment Variables Template
# Copy this file to .env and fill in the values

# ============================================
# CLOUDFLARE WORKERS CONFIGURATION
# ============================================
ENVIRONMENT=development

# ============================================
# SUPABASE CONFIGURATION (Required)
# ============================================
# Get from: https://supabase.com/dashboard/project/YOUR_PROJECT/settings/api
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key

# ============================================
# OPENAI CONFIGURATION (Required)
# ============================================
# Get from: https://platform.openai.com/api-keys
OPENAI_API_KEY=sk-your-openai-api-key

# ============================================
# CLAUDIBLE API (Optional)
# ============================================
# Enhanced AI features
CLAUDIBLE_API_KEY=your-claudible-api-key

# ============================================
# WIDGET CONFIGURATION
# ============================================
# API endpoint for widget to connect (production)
VITE_API_URL=https://smart-chat-bot.your-subdomain.workers.dev

# ============================================
# CLOUDFLARE DEPLOYMENT (For reference)
# ============================================
# These are set via Cloudflare dashboard or wrangler CLI, not .env
#
# For Workers API secrets, run:
#   wrangler secret put SUPABASE_URL
#   wrangler secret put SUPABASE_SERVICE_ROLE_KEY
#   wrangler secret put OPENAI_API_KEY
#   wrangler secret put CLAUDIBLE_API_KEY (optional)
#
# For Pages environment variables:
#   Set VITE_API_URL in Cloudflare Pages dashboard under Settings > Environment variables
</file>

<file path=".gitignore">
# Node.js / npm
node_modules/
npm-debug.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.npm
.eslintcache
.node_repl_history
*.tgz
*.pack
.yarn-integrity
dist/
build/
.turbo/

# TypeScript
*.tsbuildinfo
tsconfig.tsbuildinfo

# Environment variables (CRITICAL - NEVER COMMIT)
.env
.env.local
.env.*.local
.env.production.local
.env.development.local
.env.test.local

# IDE / Editor
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store
.sublime-workspace
.sublime-project
*.sublime-project
*.sublime-workspace
.history/
.vscode-test/
*.code-workspace

# OS files
Thumbs.db
desktop.ini
.DS_Store
.AppleDouble
.LSOverride

# Test coverage
coverage/
.nyc_output/
lcov.info
*.lcov

# Python (for RAG/AI components)
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
ENV/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
.venv/
pip-log.txt
pip-delete-this-directory.txt
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
.mypy_cache/
.dmypy.json
dmypy.json
.pyre/
.python-version
*.poetry.lock

# Jupyter Notebook
.ipynb_checkpoints
*.ipynb

# Virtual environment directories
.venv
venv
ENV
env
.virtualenv

# Python development
*.pyo
*.pyd
.Python
pip-log.txt
pip-delete-this-directory.txt

# Machine Learning / Data Science
*.pkl
*.pickle
*.h5
*.hdf5
*.joblib
*.model
*.weights
*.onnx
mlruns/
.mlflow/
wandb/
experiments/
models/
datasets/
*.csv
*.parquet

# Temporary files
*.tmp
*.temp
*.bak
*.backup
.tmp/
tmp/
temp/

# Lock files (optional - uncomment if you want to track these)
# package-lock.json
# yarn.lock
# poetry.lock
# pipenv files

# Logs
logs/
*.log
lerna-debug.log*

# Runtime data
pids/
*.pid
*.seed
*.pid.lock

# Generated files
*.generated.ts
*.generated.js

# Build artifacts
out/
.next/
.nuxt/
.cache/
.vuepress/dist/
.serverless/
.fusebox/
.dynamodb/
.tern-port
.venv/

# Electron
dist_electron/

# IDE specific
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace
.project
.pydevproject
.ropeproject

# VS Code specific
.vscode-test
.vscode/*.log
.vscode/extensions

# Database
*.db
*.sqlite
*.sqlite3
*.db-journal

# API Keys and secrets (CRITICAL)
secrets/
.secrets/
credentials.json
aws-credentials
.aws/credentials

# Local development
.local/
.docker/compose/override.yml
docker-compose.override.yml

# Backup and recovery
*.bak
*.swp
*~
.directory

# CI/CD artifacts
.github/workflows/*.log

# macOS
.AppleDouble
.LSOverride
._*
.Spotlight-V100
.Trashes

# Windows
$RECYCLE.BIN/
ehthumbs.db

# Linux
.directory

# Dependencies
node_modules/
vendor/

# Output directories
output/
results/
reports/

# Temporary build
.cache/
.webpack/

# Cloudflare Workers
.wrangler/
.dev.vars
</file>

<file path="claudible-stealth-bypass.md">
# Claudible.io — Stealth Bypass Guide

## Vấn đề

Claudible.io có 3 endpoint:

| Endpoint | Giá | Trạng thái |
|---|---|---|
| `/v1/messages` | Rẻ nhất (Claude Code tier) | Bị chặn cho API calls thường |
| `/v1/responses` | Trung bình | Mở cho tất cả |
| `/v1/chat/completions` | Trung bình (OpenAI-compat) | Mở cho tất cả |

`/v1/messages` bị reserve cho "Claude Code" — nhưng Claudible phân biệt client qua **HTTP headers**, không phải IP hay API key.

## Cách bypass

Gửi 2 headers giả Claude Code:

```
X-Claude-Client: claude-code/2.1.2
User-Agent: claude-code/2.1.2
```

Kết hợp với auth header chuẩn Anthropic:

```
x-api-key: <your-api-key>
anthropic-version: 2023-06-01
Content-Type: application/json
```

## Request format — Anthropic Messages API

```json
POST /v1/messages

{
  "model": "claude-sonnet-4.5",
  "max_tokens": 4096,
  "temperature": 0.7,
  "system": "You are a helpful assistant.",
  "messages": [
    { "role": "user", "content": "Hello" }
  ]
}
```

### Lưu ý quan trọng

- `system` là field **top-level**, KHÔNG nằm trong `messages` array
- `messages` chỉ chứa `user` và `assistant` roles
- Không có `response_format` — dùng system prompt để yêu cầu JSON
- `max_tokens` là bắt buộc (Anthropic API yêu cầu)

## Response format

```json
{
  "id": "msg_01XYZ...",
  "type": "message",
  "role": "assistant",
  "content": [
    { "type": "text", "text": "Hello! How can I help?" }
  ],
  "model": "claude-sonnet-4.5",
  "stop_reason": "end_turn",
  "usage": {
    "input_tokens": 12,
    "output_tokens": 8
  }
}
```

### Cách extract text từ response

```typescript
const text = data.content
  .filter(c => c.type === 'text')
  .map(c => c.text)
  .join('')
```

## Curl test — Copy-paste để test

```bash
curl -s -X POST https://claudible.io/v1/messages \
  -H "x-api-key: YOUR_API_KEY" \
  -H "anthropic-version: 2023-06-01" \
  -H "Content-Type: application/json" \
  -H "X-Claude-Client: claude-code/2.1.2" \
  -H "User-Agent: claude-code/2.1.2" \
  -d '{
    "model": "claude-haiku-4.5",
    "max_tokens": 100,
    "messages": [{"role": "user", "content": "Say hi"}]
  }'
```

## Models có sẵn (02/2026)

| Model ID | Tên | Context Window |
|---|---|---|
| `claude-haiku-4.5` | Claude Haiku 4.5 | 200K |
| `claude-sonnet-4.5` | Claude Sonnet 4.5 | 200K |
| `claude-opus-4.5` | Claude Opus 4.5 | 200K |
| `claude-opus-4.6` | Claude Opus 4.6 | 200K |

Check models: `GET /v1/models` (không cần stealth headers)

## TypeScript implementation mẫu

```typescript
interface ChatMessage {
  role: 'system' | 'user' | 'assistant'
  content: string
}

interface AnthropicResponse {
  content: Array<{ type: 'text'; text: string }>
  usage: { input_tokens: number; output_tokens: number }
}

async function chatCompletion(messages: ChatMessage[]): Promise<string> {
  const systemMsg = messages.find(m => m.role === 'system')
  const conversationMsgs = messages.filter(m => m.role !== 'system')

  const body: Record<string, unknown> = {
    model: 'claude-sonnet-4.5',
    max_tokens: 4096,
    messages: conversationMsgs.map(m => ({
      role: m.role,
      content: m.content,
    })),
  }

  if (systemMsg) body.system = systemMsg.content

  const res = await fetch('https://claudible.io/v1/messages', {
    method: 'POST',
    headers: {
      'x-api-key': 'YOUR_API_KEY',
      'anthropic-version': '2023-06-01',
      'Content-Type': 'application/json',
      'X-Claude-Client': 'claude-code/2.1.2',
      'User-Agent': 'claude-code/2.1.2',
    },
    body: JSON.stringify(body),
  })

  if (!res.ok) throw new Error(`API error ${res.status}: ${await res.text()}`)

  const data = (await res.json()) as AnthropicResponse
  return data.content.filter(c => c.type === 'text').map(c => c.text).join('')
}
```

## Python implementation mẫu

```python
import requests

def chat_completion(messages: list[dict], model="claude-sonnet-4.5", max_tokens=4096):
    system_msg = next((m["content"] for m in messages if m["role"] == "system"), None)
    conv_msgs = [{"role": m["role"], "content": m["content"]}
                 for m in messages if m["role"] != "system"]

    body = {"model": model, "max_tokens": max_tokens, "messages": conv_msgs}
    if system_msg:
        body["system"] = system_msg

    res = requests.post(
        "https://claudible.io/v1/messages",
        headers={
            "x-api-key": "YOUR_API_KEY",
            "anthropic-version": "2023-06-01",
            "Content-Type": "application/json",
            "X-Claude-Client": "claude-code/2.1.2",
            "User-Agent": "claude-code/2.1.2",
        },
        json=body,
    )
    res.raise_for_status()
    data = res.json()
    return "".join(c["text"] for c in data["content"] if c["type"] == "text")
```

## So sánh 3 endpoint

| | `/v1/messages` (stealth) | `/v1/responses` | `/v1/chat/completions` |
|---|---|---|---|
| Format | Anthropic-native | Anthropic responses | OpenAI-compatible |
| Giá | Rẻ nhất | Trung bình | Trung bình |
| SDK | Không cần (fetch) | Không cần (fetch) | OpenAI SDK |
| System prompt | Top-level `system` field | `instructions` field | Trong `messages` array |
| Stealth headers | Cần | Không | Không |
| JSON mode | Qua system prompt | Qua `instructions` | `response_format` |

## Nguồn gốc kỹ thuật

Phát hiện từ OpenClaw bot (v2026.2.6-3) sử dụng `@mariozechner/pi-ai` library.
File: `providers/anthropic.js` trong `@mariozechner/pi-ai` package.

```javascript
// Stealth mode: Mimic Claude Code's tool naming exactly
const claudeCodeVersion = "2.1.2";
// Headers gửi kèm khi dùng Anthropic Messages API:
// "X-Claude-Client": `claude-code/${claudeCodeVersion}`
```

## Env vars cần thiết

```env
ANTHROPIC_BASE_URL=https://claudible.io/v1
ANTHROPIC_API_KEY=sk-your-key-here
ANTHROPIC_MODEL=claude-sonnet-4.5
```
</file>

<file path="docs/deployment-guide.md">
# Deployment Guide

## Overview

Smart Chat Bot uses Cloudflare infrastructure:
- **API**: Cloudflare Workers (wrangler)
- **Widget**: Cloudflare Pages (static hosting)

## Prerequisites

1. [Cloudflare account](https://dash.cloudflare.com/sign-up)
2. [Wrangler CLI](https://developers.cloudflare.com/workers/wrangler/install-and-update/) installed
3. Supabase project with database configured
4. OpenAI API key

## Quick Start

```bash
# 1. Install dependencies
npm install
cd widget && npm install && cd ..

# 2. Login to Cloudflare
wrangler login

# 3. Set secrets
wrangler secret put SUPABASE_URL
wrangler secret put SUPABASE_SERVICE_ROLE_KEY
wrangler secret put OPENAI_API_KEY

# 4. Deploy
npm run deploy:all
```

## API Deployment (Cloudflare Workers)

### Configuration

The `wrangler.toml` file contains Workers configuration:

```toml
name = "smart-chat-bot"
main = "src/index.ts"
compatibility_date = "2026-02-01"
```

### Environments

| Environment | Command | Description |
|-------------|---------|-------------|
| Development | `npm run dev` | Local development |
| Staging | `npm run deploy:api:staging` | Testing environment |
| Production | `npm run deploy:api:production` | Live deployment |

### Setting Secrets

Secrets are stored securely in Cloudflare and not exposed in code:

```bash
# Required
wrangler secret put SUPABASE_URL
# Enter: https://your-project.supabase.co

wrangler secret put SUPABASE_SERVICE_ROLE_KEY
# Enter: your-service-role-key

wrangler secret put OPENAI_API_KEY
# Enter: sk-your-openai-api-key

# Optional
wrangler secret put CLAUDIBLE_API_KEY
# Enter: your-claudible-api-key
```

For staging environment:
```bash
wrangler secret put SUPABASE_URL --env staging
```

### Deploy Commands

```bash
# Deploy to default environment
npm run deploy:api

# Deploy to staging
npm run deploy:api:staging

# Deploy to production
npm run deploy:api:production
```

## Widget Deployment (Cloudflare Pages)

### First-Time Setup

1. Create Pages project in Cloudflare dashboard, OR
2. First deploy will auto-create the project:

```bash
npm run deploy:widget
```

### Build Configuration

Widget uses Vite for building:
- **Build command**: `npm run build`
- **Output directory**: `dist`
- **Framework preset**: None (vanilla)

### Environment Variables

Set in Cloudflare Pages dashboard (Settings > Environment Variables):

| Variable | Description |
|----------|-------------|
| `VITE_API_URL` | Workers API URL (e.g., `https://smart-chat-bot.workers.dev`) |

### Deploy Commands

```bash
# Deploy widget (preview)
npm run deploy:widget

# Deploy widget (production)
npm run deploy:widget:production
```

## Full Deployment

Deploy both API and widget:

```bash
npm run deploy:all
```

## Domain Configuration

### Custom Domain for Workers

1. Go to Cloudflare Dashboard > Workers & Pages
2. Select your worker > Settings > Triggers
3. Add custom domain (e.g., `api.yourdomain.com`)

### Custom Domain for Pages

1. Go to Cloudflare Dashboard > Workers & Pages
2. Select your Pages project > Custom domains
3. Add domain (e.g., `widget.yourdomain.com`)

## Environment URLs

| Service | Development | Production |
|---------|-------------|------------|
| API | `http://localhost:8787` | `https://smart-chat-bot.workers.dev` |
| Widget | `http://localhost:5173` | `https://smart-chat-widget.pages.dev` |

## Monitoring

### Workers Analytics

- Cloudflare Dashboard > Workers & Pages > Analytics
- Request count, CPU time, errors

### Logs

```bash
# Tail live logs
wrangler tail

# Tail staging logs
wrangler tail --env staging
```

## Troubleshooting

### Common Issues

**1. Deployment fails with authentication error**
```bash
wrangler logout
wrangler login
```

**2. Secrets not found**
```bash
# List secrets
wrangler secret list

# Re-add secret
wrangler secret put SECRET_NAME
```

**3. CORS errors on widget**
- Verify API URL in widget config
- Check Workers CORS headers configuration

**4. Pages deployment fails**
```bash
# Check build locally first
cd widget && npm run build && ls -la dist/
```

## CI/CD Integration

### GitHub Actions Example

```yaml
name: Deploy
on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm ci

      - name: Deploy API
        run: npm run deploy:api:production
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

      - name: Deploy Widget
        run: |
          cd widget && npm ci
          npm run deploy:widget:production
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
```

### Required GitHub Secrets

- `CLOUDFLARE_API_TOKEN`: Create at Cloudflare Dashboard > API Tokens

## Security Checklist

- [ ] All secrets set via `wrangler secret put` (not in code)
- [ ] Production environment uses separate database
- [ ] CORS configured for allowed origins only
- [ ] Rate limiting enabled (optional KV namespace)
- [ ] API keys have appropriate permissions/scopes
</file>

<file path="package.json">
{
  "name": "smart-chat-bot",
  "version": "1.0.0",
  "description": "Multi-tenant AI chatbot with RAG for Shopify dropshipping",
  "type": "module",
  "scripts": {
    "dev": "wrangler dev",
    "build": "tsc",
    "typecheck": "tsc --noEmit",
    "deploy": "wrangler deploy",
    "deploy:api": "wrangler deploy",
    "deploy:api:staging": "wrangler deploy --env staging",
    "deploy:api:production": "wrangler deploy --env production",
    "deploy:widget": "cd widget && npm run build && npx wrangler pages deploy dist --project-name=smart-chat-widget",
    "deploy:widget:production": "cd widget && npm run build && npx wrangler pages deploy dist --project-name=smart-chat-widget --branch=main",
    "deploy:all": "npm run deploy:api && npm run deploy:widget",
    "secrets:set": "echo 'Run: wrangler secret put SUPABASE_URL && wrangler secret put SUPABASE_SERVICE_ROLE_KEY && wrangler secret put OPENAI_API_KEY'"
  },
  "keywords": ["chatbot", "rag", "shopify", "cloudflare-workers", "hono"],
  "license": "MIT",
  "dependencies": {
    "hono": "^4.7.0",
    "@supabase/supabase-js": "^2.50.0"
  },
  "devDependencies": {
    "wrangler": "^4.6.0",
    "typescript": "^5.7.0",
    "@cloudflare/workers-types": "^4.20260210.0"
  }
}
</file>

<file path="plans/260215-0133-smart-chatbot-rag/phase-01-setup-environment.md">
# Phase 1: Setup Environment

## Context Links
- [Plan Overview](plan.md)
- [Backend Stack Report](../reports/researcher-260215-0128-backend-stack.md)

## Overview
- **Priority:** P1 - Critical
- **Status:** pending
- **Effort:** 3h

Initialize project structure with Hono for Cloudflare Workers, configure TypeScript, environment variables, and dependencies.

## Key Insights
- Hono is ultra-lightweight (~5KB), perfect for Cloudflare Workers
- Cloudflare Workers free tier: 100k req/day, sufficient for MVP
- Wrangler CLI handles local dev + deployment

## Requirements

### Functional
- Hono project with TypeScript
- Cloudflare Workers compatible
- Environment variable management
- Local development server

### Non-Functional
- Cold start <10ms
- Type-safe configuration
- .env file support for local dev

## Project Structure

```
smart-chat-bot/
├── src/
│   ├── index.ts              # Hono app entry
│   ├── routes/
│   │   ├── chat.ts           # Chat endpoints
│   │   └── health.ts         # Health check
│   ├── services/
│   │   ├── claudible.ts      # Claudible API client
│   │   ├── embeddings.ts     # OpenAI embeddings
│   │   ├── shopify.ts        # Shopify API client
│   │   └── rag.ts            # RAG pipeline
│   ├── db/
│   │   ├── client.ts         # Supabase client
│   │   └── schema.sql        # Database schema
│   ├── types/
│   │   └── index.ts          # Type definitions
│   └── config/
│       └── env.ts            # Environment config
├── widget/
│   ├── src/
│   │   ├── App.tsx           # React widget
│   │   ├── components/       # Chat components
│   │   └── hooks/            # Custom hooks
│   ├── vite.config.ts
│   └── package.json
├── extensions/
│   └── chat-widget/
│       ├── blocks/
│       │   └── chat-widget.liquid
│       └── assets/           # Built widget JS
├── wrangler.toml
├── package.json
├── tsconfig.json
└── .env.example
```

## Implementation Steps

### 1. Initialize Hono Project (30min)
```bash
npm create hono@latest . -- --template cloudflare-workers
npm install
```

### 2. Configure TypeScript (15min)
```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "bundler",
    "strict": true,
    "lib": ["ES2022"],
    "types": ["@cloudflare/workers-types"]
  }
}
```

### 3. Install Dependencies (15min)
```bash
# Core
npm install hono @supabase/supabase-js

# Dev
npm install -D wrangler typescript @cloudflare/workers-types
```

### 4. Configure Wrangler (20min)
```toml
# wrangler.toml
name = "smart-chat-bot"
main = "src/index.ts"
compatibility_date = "2026-02-01"

[vars]
ENVIRONMENT = "development"

# Secrets (set via wrangler secret put)
# CLAUDIBLE_API_KEY
# SUPABASE_URL
# SUPABASE_ANON_KEY
# OPENAI_API_KEY
# SHOPIFY_STOREFRONT_TOKEN
# SHOPIFY_ADMIN_TOKEN
```

### 5. Create Environment Config (30min)
```typescript
// src/config/env.ts
export interface Env {
  ENVIRONMENT: string
  CLAUDIBLE_API_KEY: string
  SUPABASE_URL: string
  SUPABASE_ANON_KEY: string
  OPENAI_API_KEY: string
  SHOPIFY_STORE_DOMAIN: string
  SHOPIFY_STOREFRONT_TOKEN: string
  SHOPIFY_ADMIN_TOKEN: string
}

export function validateEnv(env: Env): void {
  const required = [
    'CLAUDIBLE_API_KEY',
    'SUPABASE_URL',
    'SUPABASE_ANON_KEY',
    'OPENAI_API_KEY'
  ]
  for (const key of required) {
    if (!env[key as keyof Env]) {
      throw new Error(`Missing required env var: ${key}`)
    }
  }
}
```

### 6. Create Base Hono App (30min)
```typescript
// src/index.ts
import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { logger } from 'hono/logger'
import type { Env } from './config/env'

const app = new Hono<{ Bindings: Env }>()

// Middleware
app.use('*', logger())
app.use('*', cors({
  origin: ['https://*.myshopify.com'],
  allowMethods: ['GET', 'POST', 'OPTIONS'],
  allowHeaders: ['Content-Type', 'Authorization']
}))

// Health check
app.get('/health', (c) => c.json({ status: 'ok', timestamp: Date.now() }))

// Export for Cloudflare Workers
export default app
```

### 7. Create .env.example (10min)
```env
# Claudible API (stealth bypass)
CLAUDIBLE_API_KEY=sk-your-key

# Supabase
SUPABASE_URL=https://xxx.supabase.co
SUPABASE_ANON_KEY=eyJ...

# OpenAI (embeddings)
OPENAI_API_KEY=sk-...

# Shopify
SHOPIFY_STORE_DOMAIN=your-store.myshopify.com
SHOPIFY_STOREFRONT_TOKEN=shpat_xxx
SHOPIFY_ADMIN_TOKEN=shpat_xxx
```

### 8. Test Local Dev Server (10min)
```bash
npm run dev
# Visit http://localhost:8787/health
```

## Todo List
- [ ] Run `npm create hono@latest` with cloudflare-workers template
- [ ] Configure tsconfig.json for ES2022
- [ ] Install core dependencies (hono, supabase-js)
- [ ] Create wrangler.toml with env vars
- [ ] Create src/config/env.ts with validation
- [ ] Create src/index.ts with base app
- [ ] Create .env.example
- [ ] Test local dev server

## Success Criteria
- `npm run dev` starts local server on port 8787
- `/health` endpoint returns JSON `{ status: 'ok' }`
- TypeScript compiles without errors
- Environment validation catches missing vars

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Wrangler version mismatch | Low | Medium | Pin wrangler version in package.json |
| TypeScript config issues | Low | Low | Use Hono's template defaults |

## Security Considerations
- Never commit .env file (add to .gitignore)
- Use wrangler secret for production secrets
- Validate environment on app startup

## Next Steps
→ [Phase 2: Backend API](phase-02-backend-api.md)
</file>

<file path="plans/260215-0133-smart-chatbot-rag/phase-02-backend-api.md">
# Phase 2: Backend API

## Context Links
- [Plan Overview](plan.md)
- [Claudible Stealth Bypass](../../claudible-stealth-bypass.md)
- [Backend Stack Report](../reports/researcher-260215-0128-backend-stack.md)

## Overview
- **Priority:** P1 - Critical
- **Status:** pending
- **Effort:** 5h

Implement Hono API with Claudible integration and SSE streaming for real-time chat responses.

## Key Insights
- Claudible `/v1/messages` requires stealth headers: `X-Claude-Client`, `User-Agent`
- System prompt is top-level field, NOT in messages array
- SSE via Hono's `streamSSE` helper for token streaming
- Must handle Anthropic response format (content array)

## Requirements

### Functional
- POST /api/chat - Send message, get streaming response
- GET /api/chat/stream - SSE endpoint for responses
- Conversation history management
- Error handling with proper HTTP codes

### Non-Functional
- Response streaming <100ms first token
- Rate limiting: 100 req/min per IP
- CORS for Shopify domains

## Architecture

```
POST /api/chat
    ↓
Validate Input → Build Context (RAG) → Claudible API
    ↓
SSE Stream → Client
```

## Related Code Files

### Create
- `src/routes/chat.ts` - Chat endpoints
- `src/services/claudible.ts` - Claudible API client
- `src/middleware/rate-limit.ts` - Rate limiting

### Modify
- `src/index.ts` - Register routes

## Implementation Steps

### 1. Claudible API Client (1h)
```typescript
// src/services/claudible.ts
interface ChatMessage {
  role: 'user' | 'assistant'
  content: string
}

interface ClaudibleConfig {
  apiKey: string
  model?: string
  maxTokens?: number
}

interface StreamChunk {
  type: 'content_block_delta' | 'message_stop'
  delta?: { type: 'text_delta'; text: string }
}

export class ClaudibleClient {
  private baseUrl = 'https://claudible.io/v1'
  private model: string
  private maxTokens: number
  private apiKey: string

  constructor(config: ClaudibleConfig) {
    this.apiKey = config.apiKey
    this.model = config.model ?? 'claude-haiku-4.5'
    this.maxTokens = config.maxTokens ?? 2048
  }

  async *streamChat(
    messages: ChatMessage[],
    systemPrompt: string
  ): AsyncGenerator<string> {
    const response = await fetch(`${this.baseUrl}/messages`, {
      method: 'POST',
      headers: {
        'x-api-key': this.apiKey,
        'anthropic-version': '2023-06-01',
        'Content-Type': 'application/json',
        'X-Claude-Client': 'claude-code/2.1.2',
        'User-Agent': 'claude-code/2.1.2'
      },
      body: JSON.stringify({
        model: this.model,
        max_tokens: this.maxTokens,
        stream: true,
        system: systemPrompt,
        messages: messages.map(m => ({
          role: m.role,
          content: m.content
        }))
      })
    })

    if (!response.ok) {
      throw new Error(`Claudible API error: ${response.status}`)
    }

    const reader = response.body?.getReader()
    if (!reader) throw new Error('No response body')

    const decoder = new TextDecoder()
    let buffer = ''

    while (true) {
      const { done, value } = await reader.read()
      if (done) break

      buffer += decoder.decode(value, { stream: true })
      const lines = buffer.split('\n')
      buffer = lines.pop() || ''

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = line.slice(6)
          if (data === '[DONE]') return
          try {
            const chunk: StreamChunk = JSON.parse(data)
            if (chunk.type === 'content_block_delta' && chunk.delta?.text) {
              yield chunk.delta.text
            }
          } catch {
            // Skip invalid JSON
          }
        }
      }
    }
  }

  async chat(
    messages: ChatMessage[],
    systemPrompt: string
  ): Promise<string> {
    const response = await fetch(`${this.baseUrl}/messages`, {
      method: 'POST',
      headers: {
        'x-api-key': this.apiKey,
        'anthropic-version': '2023-06-01',
        'Content-Type': 'application/json',
        'X-Claude-Client': 'claude-code/2.1.2',
        'User-Agent': 'claude-code/2.1.2'
      },
      body: JSON.stringify({
        model: this.model,
        max_tokens: this.maxTokens,
        system: systemPrompt,
        messages
      })
    })

    if (!response.ok) {
      throw new Error(`Claudible API error: ${response.status}`)
    }

    const data = await response.json()
    return data.content
      .filter((c: any) => c.type === 'text')
      .map((c: any) => c.text)
      .join('')
  }
}
```

### 2. Chat Routes (1.5h)
```typescript
// src/routes/chat.ts
import { Hono } from 'hono'
import { streamSSE } from 'hono/streaming'
import { ClaudibleClient } from '../services/claudible'
import type { Env } from '../config/env'

interface ChatRequest {
  message: string
  conversationId?: string
  history?: Array<{ role: 'user' | 'assistant'; content: string }>
}

const chatRoutes = new Hono<{ Bindings: Env }>()

// System prompt for sales chatbot
const SYSTEM_PROMPT = `You are a helpful sales assistant for an online store.
Your goal is to help customers find products, answer questions, and assist with purchases.
Be friendly, concise, and helpful. If you don't know something, say so.

When recommending products, include:
- Product name
- Price
- Key features
- Why it's a good fit

Available actions:
- Search products
- Add to cart
- Create order
- Answer FAQs`

chatRoutes.post('/chat', async (c) => {
  const body = await c.req.json<ChatRequest>()

  if (!body.message?.trim()) {
    return c.json({ error: 'Message required' }, 400)
  }

  const client = new ClaudibleClient({
    apiKey: c.env.CLAUDIBLE_API_KEY
  })

  const messages = [
    ...(body.history || []),
    { role: 'user' as const, content: body.message }
  ]

  // Non-streaming response
  const response = await client.chat(messages, SYSTEM_PROMPT)

  return c.json({
    message: response,
    conversationId: body.conversationId || crypto.randomUUID()
  })
})

chatRoutes.post('/chat/stream', async (c) => {
  const body = await c.req.json<ChatRequest>()

  if (!body.message?.trim()) {
    return c.json({ error: 'Message required' }, 400)
  }

  const client = new ClaudibleClient({
    apiKey: c.env.CLAUDIBLE_API_KEY
  })

  const messages = [
    ...(body.history || []),
    { role: 'user' as const, content: body.message }
  ]

  return streamSSE(c, async (stream) => {
    const conversationId = body.conversationId || crypto.randomUUID()

    await stream.writeSSE({
      event: 'start',
      data: JSON.stringify({ conversationId })
    })

    try {
      for await (const chunk of client.streamChat(messages, SYSTEM_PROMPT)) {
        await stream.writeSSE({
          event: 'delta',
          data: JSON.stringify({ text: chunk })
        })
      }

      await stream.writeSSE({
        event: 'done',
        data: JSON.stringify({ conversationId })
      })
    } catch (error) {
      await stream.writeSSE({
        event: 'error',
        data: JSON.stringify({ error: 'Stream error' })
      })
    }
  })
})

export { chatRoutes }
```

### 3. Rate Limiting Middleware (45min)
```typescript
// src/middleware/rate-limit.ts
import { Context, Next } from 'hono'

interface RateLimitState {
  count: number
  resetAt: number
}

// In-memory store (per Worker isolate)
const rateLimitStore = new Map<string, RateLimitState>()

export function rateLimit(options: {
  max: number
  windowMs: number
}) {
  return async (c: Context, next: Next) => {
    const key = c.req.header('CF-Connecting-IP') || 'unknown'
    const now = Date.now()

    let state = rateLimitStore.get(key)

    if (!state || now > state.resetAt) {
      state = { count: 0, resetAt: now + options.windowMs }
      rateLimitStore.set(key, state)
    }

    state.count++

    if (state.count > options.max) {
      return c.json(
        { error: 'Rate limit exceeded', retryAfter: Math.ceil((state.resetAt - now) / 1000) },
        429
      )
    }

    c.header('X-RateLimit-Limit', options.max.toString())
    c.header('X-RateLimit-Remaining', (options.max - state.count).toString())
    c.header('X-RateLimit-Reset', Math.ceil(state.resetAt / 1000).toString())

    await next()
  }
}
```

### 4. Register Routes (30min)
```typescript
// src/index.ts (updated)
import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { logger } from 'hono/logger'
import { chatRoutes } from './routes/chat'
import { rateLimit } from './middleware/rate-limit'
import type { Env } from './config/env'

const app = new Hono<{ Bindings: Env }>()

// Global middleware
app.use('*', logger())
app.use('*', cors({
  origin: (origin) => {
    if (!origin) return '*'
    if (origin.endsWith('.myshopify.com')) return origin
    if (origin.includes('localhost')) return origin
    return null
  },
  allowMethods: ['GET', 'POST', 'OPTIONS'],
  allowHeaders: ['Content-Type']
}))

// Rate limit chat endpoints
app.use('/api/chat*', rateLimit({ max: 100, windowMs: 60000 }))

// Routes
app.get('/health', (c) => c.json({ status: 'ok', timestamp: Date.now() }))
app.route('/api', chatRoutes)

// 404 handler
app.notFound((c) => c.json({ error: 'Not found' }, 404))

// Error handler
app.onError((err, c) => {
  console.error('Error:', err)
  return c.json({ error: 'Internal server error' }, 500)
})

export default app
```

### 5. Test SSE Streaming (30min)
```bash
# Test non-streaming
curl -X POST http://localhost:8787/api/chat \
  -H "Content-Type: application/json" \
  -d '{"message": "What products do you have?"}'

# Test streaming
curl -N -X POST http://localhost:8787/api/chat/stream \
  -H "Content-Type: application/json" \
  -d '{"message": "Tell me about your best selling items"}'
```

## Todo List
- [ ] Create `src/services/claudible.ts` with streaming support
- [ ] Create `src/routes/chat.ts` with POST /chat and /chat/stream
- [ ] Create `src/middleware/rate-limit.ts`
- [ ] Update `src/index.ts` with routes and middleware
- [ ] Test streaming with curl
- [ ] Add error handling for Claudible API failures

## Success Criteria
- POST /api/chat returns JSON response
- POST /api/chat/stream returns SSE events
- Rate limit headers present in responses
- 429 returned when limit exceeded
- Graceful error handling for API failures

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Claudible API changes | Low | High | Monitor API, have fallback to /v1/responses |
| SSE connection drops | Medium | Medium | Client-side reconnection logic |
| Rate limit bypass | Low | Medium | Use CF-Connecting-IP header |

## Security Considerations
- Validate message content (max 4000 chars)
- Sanitize user input before sending to LLM
- Don't expose API keys in error messages
- Log but don't expose internal errors

## Next Steps
→ [Phase 3: Database & RAG](phase-03-database-rag.md)
</file>

<file path="plans/260215-0133-smart-chatbot-rag/phase-03-database-rag.md">
# Phase 3: Database & RAG (Multi-tenant)

## Context Links
- [Plan Overview](plan.md)
- [RAG Architecture Report](../reports/researcher-260215-0128-rag-architecture.md)

## Overview
- **Priority:** P1 - Critical
- **Status:** pending
- **Effort:** 8h

Setup multi-tenant Supabase PostgreSQL with pgvector, Row Level Security (RLS) for tenant isolation, and embedding pipeline for 2000+ products per tenant.

## Key Insights
- pgvector: No chunking needed for products (atomic units)
- OpenAI text-embedding-3-small: 1536 dims, $0.02/1M tokens
- Hybrid search: vector similarity + SQL filters (price, category)
- Supabase free tier: 500MB sufficient for ~15 tenants x 3000 products each
- RLS: Automatic tenant isolation at database level

## Multi-tenant Strategy

| Aspect | Implementation |
|--------|----------------|
| Isolation | Row Level Security (RLS) |
| Tenant ID | `tenant_id TEXT` column on all tables |
| Session Var | `SET app.tenant_id = 'shop-abc'` before queries |
| Max Tenants | 15 shops |

## Requirements

### Functional
- Store tenants with Shopify credentials
- Store products with embeddings (per tenant)
- Store FAQs with embeddings (per tenant)
- Store conversation history (per tenant)
- Semantic search with filters (auto-filtered by tenant)
- Embedding generation pipeline

### Non-Functional
- Search latency <200ms
- Support 2000+ products per tenant
- Incremental updates (no full re-index)
- Complete tenant isolation

## Database Schema

```sql
-- Enable pgvector
CREATE EXTENSION IF NOT EXISTS vector;

-- ============================================
-- TENANTS TABLE (Core multi-tenant config)
-- ============================================
CREATE TABLE tenants (
  id TEXT PRIMARY KEY,  -- 'shop-abc', 'shop-xyz'
  name TEXT NOT NULL,
  shopify_store_url TEXT,
  shopify_storefront_token TEXT,
  shopify_admin_token TEXT,
  system_prompt TEXT,  -- Custom AI prompt per tenant
  welcome_message TEXT DEFAULT 'Xin chào! Tôi có thể giúp gì cho bạn?',
  primary_color TEXT DEFAULT '#3B82F6',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================
-- PRODUCTS TABLE (with tenant_id)
-- ============================================
CREATE TABLE products (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id TEXT NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  shopify_product_id TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  price DECIMAL(10,2),
  currency TEXT DEFAULT 'VND',
  category TEXT,
  tags TEXT[],
  image_url TEXT,
  available BOOLEAN DEFAULT true,
  embedding vector(1536),
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(tenant_id, shopify_product_id)
);

-- ============================================
-- FAQs TABLE (with tenant_id)
-- ============================================
CREATE TABLE faqs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id TEXT NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  question TEXT NOT NULL,
  answer TEXT NOT NULL,
  category TEXT,
  embedding vector(1536),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================
-- CONVERSATIONS TABLE (with tenant_id)
-- ============================================
CREATE TABLE conversations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id TEXT NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  customer_id TEXT,
  customer_email TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================
-- MESSAGES TABLE (with tenant_id)
-- ============================================
CREATE TABLE messages (
  id BIGSERIAL PRIMARY KEY,
  tenant_id TEXT NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  conversation_id UUID REFERENCES conversations(id) ON DELETE CASCADE,
  role TEXT NOT NULL CHECK (role IN ('user', 'assistant', 'system')),
  content TEXT NOT NULL,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================
-- INDEXES
-- ============================================
-- Tenant-scoped vector indexes
CREATE INDEX idx_products_tenant ON products(tenant_id);
CREATE INDEX idx_products_embedding ON products
  USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);
CREATE INDEX idx_products_category ON products(tenant_id, category);
CREATE INDEX idx_products_price ON products(tenant_id, price);
CREATE INDEX idx_products_available ON products(tenant_id, available);

CREATE INDEX idx_faqs_tenant ON faqs(tenant_id);
CREATE INDEX idx_faqs_embedding ON faqs
  USING ivfflat (embedding vector_cosine_ops) WITH (lists = 50);

CREATE INDEX idx_conversations_tenant ON conversations(tenant_id);
CREATE INDEX idx_conversations_customer ON conversations(tenant_id, customer_id);

CREATE INDEX idx_messages_tenant ON messages(tenant_id);
CREATE INDEX idx_messages_conversation ON messages(conversation_id, created_at DESC);

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================
-- Enable RLS on all tenant-scoped tables
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
ALTER TABLE faqs ENABLE ROW LEVEL SECURITY;
ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;

-- RLS Policies: Filter by app.tenant_id session variable
CREATE POLICY tenant_isolation_products ON products
  FOR ALL USING (tenant_id = current_setting('app.tenant_id', true));

CREATE POLICY tenant_isolation_faqs ON faqs
  FOR ALL USING (tenant_id = current_setting('app.tenant_id', true));

CREATE POLICY tenant_isolation_conversations ON conversations
  FOR ALL USING (tenant_id = current_setting('app.tenant_id', true));

CREATE POLICY tenant_isolation_messages ON messages
  FOR ALL USING (tenant_id = current_setting('app.tenant_id', true));

-- ============================================
-- HELPER FUNCTION: Set tenant context
-- ============================================
CREATE OR REPLACE FUNCTION set_tenant_context(p_tenant_id TEXT)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  PERFORM set_config('app.tenant_id', p_tenant_id, false);
END;
$$;

-- ============================================
-- FUNCTION: Search products by similarity + filters (tenant-scoped)
-- ============================================
CREATE OR REPLACE FUNCTION search_products(
  p_tenant_id TEXT,
  query_embedding vector(1536),
  match_threshold FLOAT DEFAULT 0.5,
  match_count INT DEFAULT 5,
  filter_category TEXT DEFAULT NULL,
  filter_max_price DECIMAL DEFAULT NULL,
  filter_available BOOLEAN DEFAULT true
)
RETURNS TABLE (
  id UUID,
  shopify_product_id TEXT,
  title TEXT,
  description TEXT,
  price DECIMAL,
  category TEXT,
  image_url TEXT,
  similarity FLOAT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT
    p.id,
    p.shopify_product_id,
    p.title,
    p.description,
    p.price,
    p.category,
    p.image_url,
    1 - (p.embedding <=> query_embedding) as similarity
  FROM products p
  WHERE
    p.tenant_id = p_tenant_id
    AND (filter_available IS NULL OR p.available = filter_available)
    AND (filter_category IS NULL OR p.category = filter_category)
    AND (filter_max_price IS NULL OR p.price <= filter_max_price)
    AND 1 - (p.embedding <=> query_embedding) > match_threshold
  ORDER BY p.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

-- ============================================
-- FUNCTION: Search FAQs (tenant-scoped)
-- ============================================
CREATE OR REPLACE FUNCTION search_faqs(
  p_tenant_id TEXT,
  query_embedding vector(1536),
  match_threshold FLOAT DEFAULT 0.6,
  match_count INT DEFAULT 3
)
RETURNS TABLE (
  id UUID,
  question TEXT,
  answer TEXT,
  category TEXT,
  similarity FLOAT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT
    f.id,
    f.question,
    f.answer,
    f.category,
    1 - (f.embedding <=> query_embedding) as similarity
  FROM faqs f
  WHERE
    f.tenant_id = p_tenant_id
    AND 1 - (f.embedding <=> query_embedding) > match_threshold
  ORDER BY f.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;
```

## Related Code Files

### Create
- `src/db/client.ts` - Supabase client with tenant context
- `src/db/schema.sql` - Multi-tenant database schema
- `src/services/embeddings.ts` - OpenAI embeddings
- `src/services/rag.ts` - Tenant-scoped RAG pipeline
- `src/services/tenant.ts` - Tenant config management

## Implementation Steps

### 1. Setup Supabase Project (30min)
1. Create project at supabase.com
2. Enable pgvector extension: Database > Extensions > vector
3. Run schema.sql in SQL Editor
4. Copy project URL and service role key (for RLS bypass in backend)
5. Create first tenant record for testing

### 2. Tenant Service (30min)
```typescript
// src/services/tenant.ts
import { SupabaseClient } from '@supabase/supabase-js'
import type { Database } from '../db/client'

export interface TenantConfig {
  id: string
  name: string
  shopifyStoreUrl: string | null
  shopifyStorefrontToken: string | null
  shopifyAdminToken: string | null
  systemPrompt: string | null
  welcomeMessage: string
  primaryColor: string
}

export class TenantService {
  constructor(private db: SupabaseClient<Database>) {}

  async getConfig(tenantId: string): Promise<TenantConfig | null> {
    const { data, error } = await this.db
      .from('tenants')
      .select('*')
      .eq('id', tenantId)
      .single()

    if (error || !data) return null

    return {
      id: data.id,
      name: data.name,
      shopifyStoreUrl: data.shopify_store_url,
      shopifyStorefrontToken: data.shopify_storefront_token,
      shopifyAdminToken: data.shopify_admin_token,
      systemPrompt: data.system_prompt,
      welcomeMessage: data.welcome_message || 'Xin chào! Tôi có thể giúp gì cho bạn?',
      primaryColor: data.primary_color || '#3B82F6'
    }
  }

  async setTenantContext(tenantId: string): Promise<void> {
    await this.db.rpc('set_tenant_context', { p_tenant_id: tenantId })
  }
}
```

### 3. Supabase Client with Tenant Context (30min)
```typescript
// src/db/client.ts
import { createClient, SupabaseClient } from '@supabase/supabase-js'
import type { Env } from '../config/env'

export type Database = {
  public: {
    Tables: {
      tenants: {
        Row: {
          id: string
          name: string
          shopify_store_url: string | null
          shopify_storefront_token: string | null
          shopify_admin_token: string | null
          system_prompt: string | null
          welcome_message: string | null
          primary_color: string | null
          created_at: string
          updated_at: string
        }
        Insert: Omit<Database['public']['Tables']['tenants']['Row'], 'created_at' | 'updated_at'>
        Update: Partial<Database['public']['Tables']['tenants']['Insert']>
      }
      products: {
        Row: {
          id: string
          tenant_id: string
          shopify_product_id: string
          title: string
          description: string | null
          price: number
          currency: string
          category: string | null
          tags: string[]
          image_url: string | null
          available: boolean
          embedding: number[] | null
          metadata: Record<string, unknown>
          created_at: string
          updated_at: string
        }
        Insert: Omit<Database['public']['Tables']['products']['Row'], 'id' | 'created_at' | 'updated_at'>
        Update: Partial<Database['public']['Tables']['products']['Insert']>
      }
      faqs: {
        Row: {
          id: string
          tenant_id: string
          question: string
          answer: string
          category: string | null
          embedding: number[] | null
          created_at: string
        }
        Insert: Omit<Database['public']['Tables']['faqs']['Row'], 'id' | 'created_at'>
        Update: Partial<Database['public']['Tables']['faqs']['Insert']>
      }
      conversations: {
        Row: {
          id: string
          tenant_id: string
          customer_id: string | null
          customer_email: string | null
          created_at: string
          updated_at: string
        }
        Insert: Omit<Database['public']['Tables']['conversations']['Row'], 'id' | 'created_at' | 'updated_at'>
        Update: Partial<Database['public']['Tables']['conversations']['Insert']>
      }
      messages: {
        Row: {
          id: number
          tenant_id: string
          conversation_id: string
          role: 'user' | 'assistant' | 'system'
          content: string
          metadata: Record<string, unknown>
          created_at: string
        }
        Insert: Omit<Database['public']['Tables']['messages']['Row'], 'id' | 'created_at'>
        Update: Partial<Database['public']['Tables']['messages']['Insert']>
      }
    }
  }
}

export function createSupabaseClient(env: Env): SupabaseClient<Database> {
  // Use service role key for backend (bypasses RLS for admin operations)
  return createClient<Database>(env.SUPABASE_URL, env.SUPABASE_SERVICE_ROLE_KEY)
}

export function createSupabaseClientWithTenant(
  env: Env,
  tenantId: string
): SupabaseClient<Database> {
  return createClient<Database>(env.SUPABASE_URL, env.SUPABASE_ANON_KEY, {
    global: {
      headers: {
        'x-tenant-id': tenantId
      }
    }
  })
}
```

### 4. RAG Service (Tenant-scoped) (1.5h)
```typescript
// src/services/rag.ts
import { SupabaseClient } from '@supabase/supabase-js'
import { EmbeddingsService } from './embeddings'
import type { Database } from '../db/client'

interface SearchOptions {
  category?: string
  maxPrice?: number
  onlyAvailable?: boolean
  limit?: number
}

interface ProductResult {
  id: string
  shopify_product_id: string
  title: string
  description: string | null
  price: number
  category: string | null
  image_url: string | null
  similarity: number
}

interface FAQResult {
  id: string
  question: string
  answer: string
  category: string | null
  similarity: number
}

export class RAGService {
  constructor(
    private db: SupabaseClient<Database>,
    private embeddings: EmbeddingsService,
    private tenantId: string
  ) {}

  async searchProducts(
    query: string,
    options: SearchOptions = {}
  ): Promise<ProductResult[]> {
    const embedding = await this.embeddings.embed(query)

    const { data, error } = await this.db.rpc('search_products', {
      p_tenant_id: this.tenantId,
      query_embedding: embedding,
      match_threshold: 0.5,
      match_count: options.limit ?? 5,
      filter_category: options.category ?? null,
      filter_max_price: options.maxPrice ?? null,
      filter_available: options.onlyAvailable ?? true
    })

    if (error) throw error
    return data as ProductResult[]
  }

  async searchFAQs(query: string, limit = 3): Promise<FAQResult[]> {
    const embedding = await this.embeddings.embed(query)

    const { data, error } = await this.db.rpc('search_faqs', {
      p_tenant_id: this.tenantId,
      query_embedding: embedding,
      match_threshold: 0.6,
      match_count: limit
    })

    if (error) throw error
    return data as FAQResult[]
  }

  async buildContext(query: string): Promise<string> {
    const [products, faqs] = await Promise.all([
      this.searchProducts(query, { limit: 5 }),
      this.searchFAQs(query, 3)
    ])

    let context = ''

    if (products.length > 0) {
      context += '## Sản phẩm liên quan\n\n'
      for (const p of products) {
        context += `- **${p.title}** (${p.price.toLocaleString('vi-VN')} VND)\n`
        if (p.description) {
          context += `  ${p.description.slice(0, 200)}...\n`
        }
        context += `  [Product ID: ${p.shopify_product_id}]\n\n`
      }
    }

    if (faqs.length > 0) {
      context += '## Câu hỏi thường gặp\n\n'
      for (const f of faqs) {
        context += `Q: ${f.question}\n`
        context += `A: ${f.answer}\n\n`
      }
    }

    return context
  }

  // Sync product from Shopify (tenant-scoped)
  async upsertProduct(product: {
    shopifyProductId: string
    title: string
    description?: string
    price: number
    category?: string
    tags?: string[]
    imageUrl?: string
    available?: boolean
  }): Promise<void> {
    const textForEmbedding = [
      product.title,
      product.description || '',
      product.category || '',
      ...(product.tags || [])
    ].join(' ')

    const embedding = await this.embeddings.embed(textForEmbedding)

    const { error } = await this.db.from('products').upsert({
      tenant_id: this.tenantId,
      shopify_product_id: product.shopifyProductId,
      title: product.title,
      description: product.description || null,
      price: product.price,
      category: product.category || null,
      tags: product.tags || [],
      image_url: product.imageUrl || null,
      available: product.available ?? true,
      embedding,
      metadata: {}
    }, {
      onConflict: 'tenant_id,shopify_product_id'
    })

    if (error) throw error
  }

  // Batch sync products (tenant-scoped)
  async syncProducts(products: Array<{
    shopifyProductId: string
    title: string
    description?: string
    price: number
    category?: string
    tags?: string[]
    imageUrl?: string
    available?: boolean
  }>): Promise<{ synced: number; errors: number }> {
    let synced = 0
    let errors = 0

    // Process in batches of 50
    for (let i = 0; i < products.length; i += 50) {
      const batch = products.slice(i, i + 50)

      // Generate embeddings in batch
      const texts = batch.map(p =>
        [p.title, p.description || '', p.category || '', ...(p.tags || [])].join(' ')
      )
      const embeddings = await this.embeddings.embedBatch(texts)

      // Prepare rows with tenant_id
      const rows = batch.map((p, idx) => ({
        tenant_id: this.tenantId,
        shopify_product_id: p.shopifyProductId,
        title: p.title,
        description: p.description || null,
        price: p.price,
        category: p.category || null,
        tags: p.tags || [],
        image_url: p.imageUrl || null,
        available: p.available ?? true,
        embedding: embeddings[idx],
        metadata: {}
      }))

      const { error } = await this.db.from('products').upsert(rows, {
        onConflict: 'tenant_id,shopify_product_id'
      })

      if (error) {
        console.error('Batch sync error:', error)
        errors += batch.length
      } else {
        synced += batch.length
      }
    }

    return { synced, errors }
  }
}
```

### 5. Embeddings Service (45min)
```typescript
// src/services/embeddings.ts
interface EmbeddingResponse {
  data: Array<{ embedding: number[] }>
  usage: { total_tokens: number }
}

export class EmbeddingsService {
  private apiKey: string
  private model = 'text-embedding-3-small'

  constructor(apiKey: string) {
    this.apiKey = apiKey
  }

  async embed(text: string): Promise<number[]> {
    const response = await fetch('https://api.openai.com/v1/embeddings', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: this.model,
        input: text.slice(0, 8000)
      })
    })

    if (!response.ok) {
      throw new Error(`Embedding API error: ${response.status}`)
    }

    const data: EmbeddingResponse = await response.json()
    return data.data[0].embedding
  }

  async embedBatch(texts: string[]): Promise<number[][]> {
    const response = await fetch('https://api.openai.com/v1/embeddings', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: this.model,
        input: texts.map(t => t.slice(0, 8000))
      })
    })

    if (!response.ok) {
      throw new Error(`Embedding API error: ${response.status}`)
    }

    const data: EmbeddingResponse = await response.json()
    return data.data.map(d => d.embedding)
  }
}
```

### 6. Conversation Management (Tenant-scoped) (45min)
```typescript
// src/services/conversation.ts
import { SupabaseClient } from '@supabase/supabase-js'
import type { Database } from '../db/client'

type Message = Database['public']['Tables']['messages']['Row']

export class ConversationService {
  constructor(
    private db: SupabaseClient<Database>,
    private tenantId: string
  ) {}

  async create(customerId?: string, customerEmail?: string): Promise<string> {
    const { data, error } = await this.db
      .from('conversations')
      .insert({
        tenant_id: this.tenantId,
        customer_id: customerId || null,
        customer_email: customerEmail || null
      })
      .select('id')
      .single()

    if (error) throw error
    return data.id
  }

  async addMessage(
    conversationId: string,
    role: 'user' | 'assistant',
    content: string,
    metadata?: Record<string, unknown>
  ): Promise<void> {
    const { error } = await this.db.from('messages').insert({
      tenant_id: this.tenantId,
      conversation_id: conversationId,
      role,
      content,
      metadata: metadata || {}
    })

    if (error) throw error
  }

  async getHistory(
    conversationId: string,
    limit = 20
  ): Promise<Array<{ role: 'user' | 'assistant'; content: string }>> {
    const { data, error } = await this.db
      .from('messages')
      .select('role, content')
      .eq('tenant_id', this.tenantId)
      .eq('conversation_id', conversationId)
      .order('created_at', { ascending: true })
      .limit(limit)

    if (error) throw error
    return data.filter(m => m.role !== 'system') as Array<{ role: 'user' | 'assistant'; content: string }>
  }

  async exists(conversationId: string): Promise<boolean> {
    const { data, error } = await this.db
      .from('conversations')
      .select('id')
      .eq('tenant_id', this.tenantId)
      .eq('id', conversationId)
      .single()

    return !error && !!data
  }
}
```

### 7. Update Chat Route with Multi-tenant RAG (30min)
```typescript
// src/routes/chat.ts (updated for multi-tenant)
// Extract tenant from header and use tenant-scoped services

chatRoutes.post('/chat/stream', async (c) => {
  const tenantId = c.req.header('X-Tenant-ID')
  if (!tenantId) {
    return c.json({ error: 'X-Tenant-ID header required' }, 400)
  }

  const body = await c.req.json<ChatRequest>()
  if (!body.message?.trim()) {
    return c.json({ error: 'Message required' }, 400)
  }

  const db = createSupabaseClient(c.env)

  // Get tenant config
  const tenantService = new TenantService(db)
  const tenant = await tenantService.getConfig(tenantId)
  if (!tenant) {
    return c.json({ error: 'Tenant not found' }, 404)
  }

  const embeddings = new EmbeddingsService(c.env.OPENAI_API_KEY)
  const rag = new RAGService(db, embeddings, tenantId)
  const conversation = new ConversationService(db, tenantId)

  // Build RAG context (auto-filtered by tenant)
  const context = await rag.buildContext(body.message)

  // Use tenant's custom system prompt or default
  const systemPrompt = `${tenant.systemPrompt || BASE_SYSTEM_PROMPT}

## Ngữ cảnh hiện tại
${context}

Sử dụng ngữ cảnh trên để trả lời câu hỏi. Đề cập tên và giá sản phẩm cụ thể.`

  // Rest of streaming implementation...
})
```

## Todo List
- [ ] Create Supabase project and enable pgvector
- [ ] Run multi-tenant schema.sql in Supabase SQL Editor
- [ ] Create `src/services/tenant.ts`
- [ ] Create `src/db/client.ts` with tenant context
- [ ] Create `src/services/embeddings.ts`
- [ ] Create `src/services/rag.ts` (tenant-scoped)
- [ ] Create `src/services/conversation.ts` (tenant-scoped)
- [ ] Update chat routes with X-Tenant-ID header extraction
- [ ] Test RLS policies with multiple tenants
- [ ] Test product search returns only tenant's products
- [ ] Test conversation history isolation

## Success Criteria
- pgvector extension enabled in Supabase
- RLS policies enforce tenant isolation
- Product search returns only tenant's products
- FAQ search returns only tenant's FAQs
- Conversation history isolated per tenant
- Batch sync handles 2000+ products per tenant

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| RLS bypass vulnerability | Low | High | Use service role only in backend, verify tenant header |
| Embedding API cost spike | Medium | Medium | Batch embeddings, cache common queries |
| pgvector slow on cold start | Low | Low | Use HNSW index, warm connection pool |
| Supabase 500MB limit | Medium | Medium | Monitor usage, upgrade if >10 tenants |

## Security Considerations
- RLS policies auto-filter all queries by tenant_id
- Never trust tenant_id from client - validate against tenants table
- Use service role key only in backend (bypasses RLS for admin ops)
- Don't expose raw embeddings in API responses
- Validate conversation ownership before history access
- Store Shopify tokens encrypted (or use Supabase Vault)

## Next Steps
-> [Phase 4: Shopify Integration](phase-04-shopify-integration.md)
</file>

<file path="plans/260215-0133-smart-chatbot-rag/phase-04-shopify-integration.md">
# Phase 4: Shopify Integration (Multi-tenant)

## Context Links
- [Plan Overview](plan.md)
- [Shopify Integration Report](../reports/researcher-260215-0128-shopify-integration.md)

## Overview
- **Priority:** P1 - Critical
- **Status:** pending
- **Effort:** 6h

Multi-tenant Shopify integration: each tenant has own Shopify store credentials stored in `tenants` table. Widget embeds on ANY website (Next.js, WordPress, etc), checkout redirects to tenant's Shopify store.

## Key Insights
- User's main website is Next.js (shows products)
- Checkout redirects to Shopify (per tenant config)
- Widget embeds via iframe on external site
- Each tenant has own Storefront API + Admin API tokens
- Storefront API: Public, rate-limited per buyer IP
- Admin API: Backend only, requires `write_draft_orders` scope

## External Site + Shopify Flow

```
[User's Next.js Site]
    ↓ displays products
[User browses & clicks chat]
    ↓ opens iframe widget
[Chat Widget (Cloudflare Pages)]
    ↓ API call with X-Tenant-ID
[Cloudflare Workers API]
    ↓ lookup tenant's Shopify credentials
[Shopify Storefront API] → Cart creation
    ↓ returns checkoutUrl
[Widget shows "Checkout" button]
    ↓ user clicks
[Redirect to Shopify Checkout]
    ↓ complete payment on Shopify
[Order confirmed]
```

## Requirements

### Functional
- Search products via Storefront API (per tenant)
- Create/update cart (per tenant's Shopify store)
- Create draft orders (Admin API, per tenant)
- Sync product catalog to RAG database (per tenant)
- Return checkoutUrl for redirect to Shopify

### Non-Functional
- Cart operations <500ms
- Handle Shopify rate limits gracefully
- Support multi-currency (per tenant config)

## Architecture

```
[Widget] → [Backend API]
              ├── X-Tenant-ID header
              ├── Lookup tenant config
              ├── Storefront API (products, cart, checkoutUrl)
              └── Admin API (draft orders)

[Webhook] → [Backend API] → [Supabase]
              ├── X-Shopify-Shop-Domain header
              └── Product sync (tenant-scoped)
```

## Related Code Files

### Create
- `src/services/shopify-storefront.ts` - Storefront API client (per tenant)
- `src/services/shopify-admin.ts` - Admin API client (per tenant)
- `src/services/shopify-factory.ts` - Factory to create clients from tenant config
- `src/routes/shopify.ts` - Shopify webhooks (multi-tenant)
- `src/routes/cart.ts` - Cart operations (multi-tenant)

## Implementation Steps

### 1. Shopify Factory Service (30min)
```typescript
// src/services/shopify-factory.ts
import { ShopifyStorefrontClient } from './shopify-storefront'
import { ShopifyAdminClient } from './shopify-admin'
import { TenantConfig } from './tenant'

export class ShopifyFactory {
  static createStorefrontClient(tenant: TenantConfig): ShopifyStorefrontClient | null {
    if (!tenant.shopifyStoreUrl || !tenant.shopifyStorefrontToken) {
      return null
    }
    return new ShopifyStorefrontClient({
      storeDomain: tenant.shopifyStoreUrl,
      storefrontToken: tenant.shopifyStorefrontToken
    })
  }

  static createAdminClient(tenant: TenantConfig): ShopifyAdminClient | null {
    if (!tenant.shopifyStoreUrl || !tenant.shopifyAdminToken) {
      return null
    }
    return new ShopifyAdminClient({
      storeDomain: tenant.shopifyStoreUrl,
      adminToken: tenant.shopifyAdminToken
    })
  }
}
```

### 2. Storefront API Client (1h)
```typescript
// src/services/shopify-storefront.ts
interface ShopifyStorefrontConfig {
  storeDomain: string
  storefrontToken: string
}

interface ProductEdge {
  node: {
    id: string
    title: string
    handle: string
    description: string
    featuredImage?: { url: string }
    variants: {
      edges: Array<{
        node: {
          id: string
          title: string
          price: { amount: string; currencyCode: string }
          availableForSale: boolean
        }
      }>
    }
  }
}

interface CartResponse {
  id: string
  checkoutUrl: string
  totalQuantity: number
  lines: {
    edges: Array<{
      node: {
        id: string
        quantity: number
        merchandise: {
          id: string
          title: string
        }
      }
    }>
  }
}

export class ShopifyStorefrontClient {
  private endpoint: string
  private token: string

  constructor(config: ShopifyStorefrontConfig) {
    this.endpoint = `https://${config.storeDomain}/api/2026-01/graphql.json`
    this.token = config.storefrontToken
  }

  private async query<T>(query: string, variables?: Record<string, unknown>): Promise<T> {
    const response = await fetch(this.endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Shopify-Storefront-Access-Token': this.token
      },
      body: JSON.stringify({ query, variables })
    })

    const json = await response.json()
    if (json.errors) {
      throw new Error(json.errors[0].message)
    }
    return json.data
  }

  async searchProducts(searchQuery: string, first = 10): Promise<ProductEdge[]> {
    const query = `
      query SearchProducts($query: String!, $first: Int!) {
        products(first: $first, query: $query) {
          edges {
            node {
              id
              title
              handle
              description
              featuredImage { url }
              variants(first: 5) {
                edges {
                  node {
                    id
                    title
                    price { amount currencyCode }
                    availableForSale
                  }
                }
              }
            }
          }
        }
      }
    `
    const data = await this.query<{ products: { edges: ProductEdge[] } }>(query, {
      query: searchQuery,
      first
    })
    return data.products.edges
  }

  async getProduct(handle: string): Promise<ProductEdge['node'] | null> {
    const query = `
      query GetProduct($handle: String!) {
        productByHandle(handle: $handle) {
          id
          title
          handle
          description
          featuredImage { url }
          variants(first: 10) {
            edges {
              node {
                id
                title
                price { amount currencyCode }
                availableForSale
              }
            }
          }
        }
      }
    `
    const data = await this.query<{ productByHandle: ProductEdge['node'] | null }>(query, {
      handle
    })
    return data.productByHandle
  }

  async createCart(
    variantId: string,
    quantity = 1,
    buyerEmail?: string
  ): Promise<CartResponse> {
    const query = `
      mutation CartCreate($input: CartInput!) {
        cartCreate(input: $input) {
          cart {
            id
            checkoutUrl
            totalQuantity
            lines(first: 10) {
              edges {
                node {
                  id
                  quantity
                  merchandise {
                    ... on ProductVariant {
                      id
                      title
                    }
                  }
                }
              }
            }
          }
          userErrors { field message }
        }
      }
    `
    const input: Record<string, unknown> = {
      lines: [{ merchandiseId: variantId, quantity }]
    }
    if (buyerEmail) {
      input.buyerIdentity = { email: buyerEmail }
    }

    const data = await this.query<{
      cartCreate: { cart: CartResponse; userErrors: Array<{ message: string }> }
    }>(query, { input })

    if (data.cartCreate.userErrors.length > 0) {
      throw new Error(data.cartCreate.userErrors[0].message)
    }
    return data.cartCreate.cart
  }

  async addToCart(cartId: string, variantId: string, quantity = 1): Promise<CartResponse> {
    const query = `
      mutation CartLinesAdd($cartId: ID!, $lines: [CartLineInput!]!) {
        cartLinesAdd(cartId: $cartId, lines: $lines) {
          cart {
            id
            checkoutUrl
            totalQuantity
            lines(first: 10) {
              edges {
                node {
                  id
                  quantity
                  merchandise {
                    ... on ProductVariant {
                      id
                      title
                    }
                  }
                }
              }
            }
          }
          userErrors { field message }
        }
      }
    `
    const data = await this.query<{
      cartLinesAdd: { cart: CartResponse; userErrors: Array<{ message: string }> }
    }>(query, {
      cartId,
      lines: [{ merchandiseId: variantId, quantity }]
    })

    if (data.cartLinesAdd.userErrors.length > 0) {
      throw new Error(data.cartLinesAdd.userErrors[0].message)
    }
    return data.cartLinesAdd.cart
  }
}
```

### 2. Admin API Client (1h)
```typescript
// src/services/shopify-admin.ts
interface ShopifyAdminConfig {
  storeDomain: string
  adminToken: string
}

interface DraftOrderLineItem {
  variantId?: string
  title?: string
  originalUnitPrice?: number
  quantity: number
}

interface DraftOrderResponse {
  id: string
  invoiceUrl: string
  status: string
  totalPrice: string
  lineItems: {
    edges: Array<{
      node: {
        title: string
        quantity: number
      }
    }>
  }
}

export class ShopifyAdminClient {
  private endpoint: string
  private token: string

  constructor(config: ShopifyAdminConfig) {
    this.endpoint = `https://${config.storeDomain}/admin/api/2026-01/graphql.json`
    this.token = config.adminToken
  }

  private async query<T>(query: string, variables?: Record<string, unknown>): Promise<T> {
    const response = await fetch(this.endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Shopify-Access-Token': this.token
      },
      body: JSON.stringify({ query, variables })
    })

    const json = await response.json()
    if (json.errors) {
      throw new Error(json.errors[0].message)
    }
    return json.data
  }

  async createDraftOrder(options: {
    lineItems: DraftOrderLineItem[]
    customerId?: string
    email?: string
    note?: string
    discountPercent?: number
  }): Promise<DraftOrderResponse> {
    const query = `
      mutation DraftOrderCreate($input: DraftOrderInput!) {
        draftOrderCreate(input: $input) {
          draftOrder {
            id
            invoiceUrl
            status
            totalPriceSet { shopMoney { amount } }
            lineItems(first: 20) {
              edges {
                node {
                  title
                  quantity
                }
              }
            }
          }
          userErrors { field message }
        }
      }
    `

    const input: Record<string, unknown> = {
      lineItems: options.lineItems.map(item => {
        if (item.variantId) {
          return { variantId: item.variantId, quantity: item.quantity }
        }
        return {
          title: item.title,
          originalUnitPrice: item.originalUnitPrice,
          quantity: item.quantity
        }
      })
    }

    if (options.customerId) {
      input.customerId = options.customerId
    }
    if (options.email) {
      input.email = options.email
    }
    if (options.note) {
      input.note = options.note
    }
    if (options.discountPercent) {
      input.appliedDiscount = {
        valueType: 'PERCENTAGE',
        value: options.discountPercent
      }
    }

    const data = await this.query<{
      draftOrderCreate: {
        draftOrder: DraftOrderResponse & { totalPriceSet: { shopMoney: { amount: string } } }
        userErrors: Array<{ message: string }>
      }
    }>(query, { input })

    if (data.draftOrderCreate.userErrors.length > 0) {
      throw new Error(data.draftOrderCreate.userErrors[0].message)
    }

    return {
      ...data.draftOrderCreate.draftOrder,
      totalPrice: data.draftOrderCreate.draftOrder.totalPriceSet.shopMoney.amount
    }
  }

  async sendDraftOrderInvoice(draftOrderId: string, email: string): Promise<void> {
    const query = `
      mutation DraftOrderInvoiceSend($id: ID!, $email: EmailInput!) {
        draftOrderInvoiceSend(id: $id, email: $email) {
          draftOrder { id }
          userErrors { field message }
        }
      }
    `

    const data = await this.query<{
      draftOrderInvoiceSend: { userErrors: Array<{ message: string }> }
    }>(query, {
      id: draftOrderId,
      email: { to: email }
    })

    if (data.draftOrderInvoiceSend.userErrors.length > 0) {
      throw new Error(data.draftOrderInvoiceSend.userErrors[0].message)
    }
  }

  // Fetch all products for initial sync
  async fetchAllProducts(cursor?: string): Promise<{
    products: Array<{
      id: string
      title: string
      description: string
      handle: string
      productType: string
      tags: string[]
      featuredImage?: { url: string }
      variants: Array<{
        id: string
        price: string
        availableForSale: boolean
      }>
    }>
    hasNextPage: boolean
    endCursor: string | null
  }> {
    const query = `
      query FetchProducts($first: Int!, $after: String) {
        products(first: $first, after: $after) {
          edges {
            node {
              id
              title
              description
              handle
              productType
              tags
              featuredImage { url }
              variants(first: 1) {
                edges {
                  node {
                    id
                    price
                    availableForSale
                  }
                }
              }
            }
          }
          pageInfo {
            hasNextPage
            endCursor
          }
        }
      }
    `

    const data = await this.query<{
      products: {
        edges: Array<{
          node: {
            id: string
            title: string
            description: string
            handle: string
            productType: string
            tags: string[]
            featuredImage?: { url: string }
            variants: { edges: Array<{ node: { id: string; price: string; availableForSale: boolean } }> }
          }
        }>
        pageInfo: { hasNextPage: boolean; endCursor: string | null }
      }
    }>(query, { first: 50, after: cursor || null })

    return {
      products: data.products.edges.map(e => ({
        ...e.node,
        variants: e.node.variants.edges.map(v => v.node)
      })),
      hasNextPage: data.products.pageInfo.hasNextPage,
      endCursor: data.products.pageInfo.endCursor
    }
  }
}
```

### 3. Product Sync Endpoint (Multi-tenant) (45min)
```typescript
// src/routes/shopify.ts
import { Hono } from 'hono'
import { ShopifyFactory } from '../services/shopify-factory'
import { RAGService } from '../services/rag'
import { TenantService } from '../services/tenant'
import { createSupabaseClient } from '../db/client'
import { EmbeddingsService } from '../services/embeddings'
import type { Env } from '../config/env'

const shopifyRoutes = new Hono<{ Bindings: Env }>()

// Sync all products from Shopify to RAG database (tenant-scoped)
shopifyRoutes.post('/sync/products', async (c) => {
  const tenantId = c.req.header('X-Tenant-ID')
  if (!tenantId) {
    return c.json({ error: 'X-Tenant-ID required' }, 400)
  }

  const db = createSupabaseClient(c.env)
  const tenantService = new TenantService(db)
  const tenant = await tenantService.getConfig(tenantId)

  if (!tenant) {
    return c.json({ error: 'Tenant not found' }, 404)
  }

  const admin = ShopifyFactory.createAdminClient(tenant)
  if (!admin) {
    return c.json({ error: 'Shopify not configured for this tenant' }, 400)
  }

  const embeddings = new EmbeddingsService(c.env.OPENAI_API_KEY)
  const rag = new RAGService(db, embeddings, tenantId)

  let cursor: string | undefined
  let totalSynced = 0
  let totalErrors = 0

  do {
    const { products, hasNextPage, endCursor } = await admin.fetchAllProducts(cursor)

    const formatted = products.map(p => ({
      shopifyProductId: p.id.replace('gid://shopify/Product/', ''),
      title: p.title,
      description: p.description,
      price: parseFloat(p.variants[0]?.price || '0'),
      category: p.productType || undefined,
      tags: p.tags,
      imageUrl: p.featuredImage?.url,
      available: p.variants[0]?.availableForSale ?? false
    }))

    const { synced, errors } = await rag.syncProducts(formatted)
    totalSynced += synced
    totalErrors += errors

    cursor = hasNextPage ? (endCursor || undefined) : undefined
  } while (cursor)

  return c.json({
    success: true,
    tenantId,
    synced: totalSynced,
    errors: totalErrors
  })
})

// Webhook: Product created/updated (identify tenant by shop domain)
shopifyRoutes.post('/webhooks/products/update', async (c) => {
  const shopDomain = c.req.header('X-Shopify-Shop-Domain')
  if (!shopDomain) {
    return c.json({ error: 'Missing shop domain' }, 400)
  }

  // TODO: Verify webhook HMAC signature

  const db = createSupabaseClient(c.env)

  // Find tenant by Shopify store URL
  const { data: tenant } = await db
    .from('tenants')
    .select('id')
    .eq('shopify_store_url', shopDomain)
    .single()

  if (!tenant) {
    return c.json({ error: 'Tenant not found for shop' }, 404)
  }

  const product = await c.req.json()
  const embeddings = new EmbeddingsService(c.env.OPENAI_API_KEY)
  const rag = new RAGService(db, embeddings, tenant.id)

  await rag.upsertProduct({
    shopifyProductId: product.id.toString(),
    title: product.title,
    description: product.body_html?.replace(/<[^>]*>/g, '') || '',
    price: parseFloat(product.variants?.[0]?.price || '0'),
    category: product.product_type || undefined,
    tags: product.tags?.split(', ') || [],
    imageUrl: product.image?.src,
    available: product.variants?.[0]?.inventory_quantity > 0
  })

  return c.json({ received: true })
})

export { shopifyRoutes }
```

### 4. Cart Operations Route (Multi-tenant) (45min)
```typescript
// src/routes/cart.ts
import { Hono } from 'hono'
import { ShopifyFactory } from '../services/shopify-factory'
import { TenantService } from '../services/tenant'
import { createSupabaseClient } from '../db/client'
import type { Env } from '../config/env'

const cartRoutes = new Hono<{ Bindings: Env }>()

// Create cart or add to existing cart
cartRoutes.post('/cart/add', async (c) => {
  const tenantId = c.req.header('X-Tenant-ID')
  if (!tenantId) {
    return c.json({ error: 'X-Tenant-ID required' }, 400)
  }

  const body = await c.req.json<{
    variantId: string
    quantity?: number
    cartId?: string
  }>()

  if (!body.variantId) {
    return c.json({ error: 'variantId required' }, 400)
  }

  const db = createSupabaseClient(c.env)
  const tenantService = new TenantService(db)
  const tenant = await tenantService.getConfig(tenantId)

  if (!tenant) {
    return c.json({ error: 'Tenant not found' }, 404)
  }

  const storefront = ShopifyFactory.createStorefrontClient(tenant)
  if (!storefront) {
    return c.json({ error: 'Shopify not configured' }, 400)
  }

  try {
    let cart
    if (body.cartId) {
      cart = await storefront.addToCart(body.cartId, body.variantId, body.quantity || 1)
    } else {
      cart = await storefront.createCart(body.variantId, body.quantity || 1)
    }

    return c.json({
      success: true,
      cartId: cart.id,
      totalQuantity: cart.totalQuantity,
      checkoutUrl: cart.checkoutUrl  // <-- Redirect user to this URL
    })
  } catch (error) {
    return c.json({ error: (error as Error).message }, 500)
  }
})

// Get cart info
cartRoutes.get('/cart/:cartId', async (c) => {
  const tenantId = c.req.header('X-Tenant-ID')
  if (!tenantId) {
    return c.json({ error: 'X-Tenant-ID required' }, 400)
  }

  const cartId = c.req.param('cartId')

  const db = createSupabaseClient(c.env)
  const tenantService = new TenantService(db)
  const tenant = await tenantService.getConfig(tenantId)

  if (!tenant) {
    return c.json({ error: 'Tenant not found' }, 404)
  }

  const storefront = ShopifyFactory.createStorefrontClient(tenant)
  if (!storefront) {
    return c.json({ error: 'Shopify not configured' }, 400)
  }

  try {
    const cart = await storefront.getCart(cartId)
    return c.json({
      success: true,
      cart,
      checkoutUrl: cart.checkoutUrl
    })
  } catch (error) {
    return c.json({ error: (error as Error).message }, 500)
  }
})

export { cartRoutes }
```

### 5. Update Storefront Client with getCart (15min)
```typescript
// Add to src/services/shopify-storefront.ts

async getCart(cartId: string): Promise<CartResponse> {
  const query = `
    query GetCart($cartId: ID!) {
      cart(id: $cartId) {
        id
        checkoutUrl
        totalQuantity
        cost {
          totalAmount { amount currencyCode }
        }
        lines(first: 20) {
          edges {
            node {
              id
              quantity
              merchandise {
                ... on ProductVariant {
                  id
                  title
                  image { url }
                  price { amount currencyCode }
                  product { title }
                }
              }
            }
          }
        }
      }
    }
  `
  const data = await this.query<{ cart: CartResponse }>(query, { cartId })
  return data.cart
}
```

## Todo List
- [ ] Create `src/services/shopify-factory.ts`
- [ ] Create `src/services/shopify-storefront.ts` (unchanged, add getCart)
- [ ] Create `src/services/shopify-admin.ts` (unchanged)
- [ ] Create `src/routes/shopify.ts` with multi-tenant sync
- [ ] Create `src/routes/cart.ts` with multi-tenant cart ops
- [ ] Test product sync per tenant
- [ ] Test cart creation returns checkoutUrl
- [ ] Test checkout redirect to Shopify
- [ ] Test draft order creation

## Success Criteria
- Product sync populates only tenant's products in RAG
- Cart operations return valid checkoutUrl
- User can redirect to Shopify checkout from widget
- Draft orders created with correct tenant's Shopify store
- Webhooks identify tenant by shop domain

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Shopify rate limits | Medium | Medium | Implement exponential backoff |
| API version deprecation | Low | High | Use stable 2026-01 version |
| Webhook tenant mismatch | Medium | High | Validate shop domain against tenants table |
| Token exposure | Low | High | Store tokens in Supabase Vault |

## Security Considerations
- Never expose Admin API token to frontend
- Verify webhook signatures with per-tenant secrets
- Validate tenant ownership before API calls
- Use Storefront API for client-facing operations
- Store Shopify tokens encrypted

## Next Steps
-> [Phase 5: Chat Widget (Iframe)](phase-05-chat-widget.md)
</file>

<file path="plans/260215-0133-smart-chatbot-rag/phase-05-chat-widget.md">
# Phase 5: Universal Iframe Widget (Cloudflare Pages)

## Context Links
- [Plan Overview](plan.md)
- [Shopify Integration Report](../reports/researcher-260215-0128-shopify-integration.md)

## Overview
- **Priority:** P1 - Critical
- **Status:** pending
- **Effort:** 6h

Build universal chat widget embeddable on ANY website (Next.js, WordPress, Shopify, etc) via simple script tag. Widget runs in iframe hosted on Cloudflare Pages for security isolation.

## Key Insights
- **Iframe approach**: Security isolation, no CSS conflicts, works everywhere
- **Embed script**: Tiny loader (~2KB) creates iframe pointing to Cloudflare Pages
- **Multi-tenant**: Widget passes `data-tenant` attribute to iframe
- **Cloudflare Pages**: Free hosting, global CDN, auto-deploy from Git

## Embed Usage (for website owners)

```html
<!-- Paste this before </body> on any website -->
<script
  src="https://widget.smartchat.example/embed.js"
  data-tenant="shop-abc"
  data-position="bottom-right"
  async
></script>
```

## Architecture

```
[Any Website]
    ↓ loads embed.js (~2KB)
[Embed Script]
    ↓ creates iframe
[Iframe src="https://widget.smartchat.example/?tenant=shop-abc"]
    ↓ React app loads
[Cloudflare Pages (Widget App)]
    ↓ API calls with X-Tenant-ID header
[Cloudflare Workers API]
```

## File Structure

```
widget/                          # React app for Cloudflare Pages
├── src/
│   ├── main.tsx                 # Entry point
│   ├── App.tsx                  # Main app
│   ├── components/
│   │   ├── ChatWindow.tsx
│   │   ├── MessageList.tsx
│   │   ├── MessageInput.tsx
│   │   ├── ProductCard.tsx
│   │   └── LoadingDots.tsx
│   ├── hooks/
│   │   └── use-chat.ts
│   └── styles/
│       └── widget.css
├── public/
│   └── embed.js                 # Embed script for websites
├── vite.config.ts
├── package.json
└── wrangler.toml                # Cloudflare Pages config

## Requirements

### Functional
- Embed via single script tag
- Works on Next.js, WordPress, Shopify, any HTML page
- Chat bubble launcher (toggle iframe visibility)
- Streaming message display
- Product cards with "Add to Cart"
- Checkout redirect to Shopify

### Non-Functional
- Embed script <3KB
- Widget app <100KB gzipped
- First paint <200ms
- Mobile responsive
- No CSS conflicts with host site

## Implementation Steps

### 1. Embed Script (45min)
```javascript
// widget/public/embed.js
// Tiny loader that creates iframe - hosted alongside widget
(function() {
  'use strict';

  // Get config from script tag
  var script = document.currentScript;
  var tenant = script.getAttribute('data-tenant');
  var position = script.getAttribute('data-position') || 'bottom-right';
  var apiUrl = script.getAttribute('data-api') || 'https://api.smartchat.example';

  if (!tenant) {
    console.error('[SmartChat] Missing data-tenant attribute');
    return;
  }

  // Widget base URL (same origin as embed.js)
  var widgetUrl = script.src.replace('/embed.js', '/');

  // Create container
  var container = document.createElement('div');
  container.id = 'smartchat-widget-container';
  container.style.cssText = 'position:fixed;z-index:2147483647;' +
    (position === 'bottom-left' ? 'bottom:20px;left:20px;' : 'bottom:20px;right:20px;');

  // Create toggle button
  var button = document.createElement('button');
  button.id = 'smartchat-toggle';
  button.setAttribute('aria-label', 'Chat');
  button.style.cssText = 'width:56px;height:56px;border-radius:50%;border:none;' +
    'background:#3B82F6;color:#fff;cursor:pointer;box-shadow:0 4px 12px rgba(0,0,0,0.15);' +
    'display:flex;align-items:center;justify-content:center;';
  button.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">' +
    '<path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg>';

  // Create iframe (hidden by default)
  var iframe = document.createElement('iframe');
  iframe.id = 'smartchat-iframe';
  iframe.src = widgetUrl + '?tenant=' + encodeURIComponent(tenant) +
    '&api=' + encodeURIComponent(apiUrl);
  iframe.style.cssText = 'display:none;width:380px;height:520px;border:none;' +
    'border-radius:16px;box-shadow:0 8px 32px rgba(0,0,0,0.15);margin-bottom:12px;';
  iframe.setAttribute('allow', 'clipboard-write');

  // Toggle visibility
  var isOpen = false;
  button.addEventListener('click', function() {
    isOpen = !isOpen;
    iframe.style.display = isOpen ? 'block' : 'none';
    button.innerHTML = isOpen
      ? '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>'
      : '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg>';
  });

  // Mobile responsive
  if (window.innerWidth <= 420) {
    iframe.style.width = 'calc(100vw - 40px)';
    iframe.style.height = 'calc(100vh - 120px)';
  }

  // Append
  container.appendChild(iframe);
  container.appendChild(button);
  document.body.appendChild(container);
})();
```

### 2. Widget Project Setup (30min)
```bash
cd widget
npm init -y
npm install preact
npm install -D vite @preact/preset-vite typescript
```

```json
// widget/package.json
{
  "name": "smart-chat-widget",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "deploy": "wrangler pages deploy dist"
  },
  "dependencies": {
    "preact": "^10.19.0"
  },
  "devDependencies": {
    "@preact/preset-vite": "^2.8.0",
    "typescript": "^5.3.0",
    "vite": "^5.0.0",
    "wrangler": "^3.0.0"
  }
}
```

### 3. Vite Configuration for Cloudflare Pages (20min)
```typescript
// widget/vite.config.ts
import { defineConfig } from 'vite'
import preact from '@preact/preset-vite'

export default defineConfig({
  plugins: [preact()],
  build: {
    outDir: 'dist',
    // Cloudflare Pages serves from dist/
    rollupOptions: {
      output: {
        // No hashes for predictable URLs
        entryFileNames: 'assets/widget.js',
        chunkFileNames: 'assets/[name].js',
        assetFileNames: 'assets/[name].[ext]'
      }
    },
    minify: 'terser',
    terserOptions: {
      compress: { drop_console: true }
    }
  },
  define: {
    'process.env.NODE_ENV': '"production"'
  }
})
```

### 4. Entry Point - Read tenant from URL (20min)
```tsx
// widget/src/main.tsx
import { render } from 'preact'
import { App } from './App'
import './styles/widget.css'

function init() {
  const params = new URLSearchParams(window.location.search)
  const tenant = params.get('tenant')
  const apiUrl = params.get('api') || 'https://api.smartchat.example'

  if (!tenant) {
    console.error('[SmartChat] Missing tenant parameter')
    return
  }

  const config = {
    tenantId: tenant,
    apiUrl
  }

  render(<App config={config} />, document.getElementById('app')!)
}

init()
```

### 5. Main App Component (30min)
```tsx
// widget/src/App.tsx
import { ChatWindow } from './components/ChatWindow'

export interface WidgetConfig {
  tenantId: string
  apiUrl: string
}

interface AppProps {
  config: WidgetConfig
}

export function App({ config }: AppProps) {
  // Widget is always "open" inside iframe
  // Toggle is handled by embed.js
  return <ChatWindow config={config} />
}
```

### 6. Chat Hook with SSE (Multi-tenant) (1h)
```typescript
// widget/src/hooks/use-chat.ts
import { useState, useCallback, useRef } from 'preact/hooks'
import type { WidgetConfig } from '../App'

export interface Message {
  id: string
  role: 'user' | 'assistant'
  content: string
  products?: ProductCard[]
  actions?: ChatAction[]
}

export interface ProductCard {
  id: string
  title: string
  price: string
  image?: string
  variantId: string
}

export interface ChatAction {
  type: 'add_to_cart' | 'checkout'
  label: string
  variantId?: string
  url?: string
}

interface UseChatReturn {
  messages: Message[]
  isLoading: boolean
  cartId: string | null
  checkoutUrl: string | null
  sendMessage: (content: string) => Promise<void>
  executeAction: (action: ChatAction) => Promise<void>
}

export function useChat(config: WidgetConfig): UseChatReturn {
  const [messages, setMessages] = useState<Message[]>([
    {
      id: 'welcome',
      role: 'assistant',
      content: 'Xin chào! Tôi có thể giúp gì cho bạn?'
    }
  ])
  const [isLoading, setIsLoading] = useState(false)
  const [conversationId, setConversationId] = useState<string | null>(null)
  const [cartId, setCartId] = useState<string | null>(null)
  const [checkoutUrl, setCheckoutUrl] = useState<string | null>(null)
  const abortRef = useRef<AbortController | null>(null)

  const sendMessage = useCallback(async (content: string) => {
    if (!content.trim() || isLoading) return

    const userMessage: Message = {
      id: `user-${Date.now()}`,
      role: 'user',
      content
    }
    setMessages(prev => [...prev, userMessage])
    setIsLoading(true)

    const assistantId = `assistant-${Date.now()}`
    setMessages(prev => [...prev, {
      id: assistantId,
      role: 'assistant',
      content: ''
    }])

    try {
      abortRef.current = new AbortController()

      const response = await fetch(`${config.apiUrl}/api/chat/stream`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Tenant-ID': config.tenantId  // <-- Multi-tenant header
        },
        body: JSON.stringify({
          message: content,
          conversationId,
          cartId
        }),
        signal: abortRef.current.signal
      })

      if (!response.ok) {
        throw new Error('Chat request failed')
      }

      const reader = response.body?.getReader()
      if (!reader) throw new Error('No response body')

      const decoder = new TextDecoder()
      let buffer = ''

      while (true) {
        const { done, value } = await reader.read()
        if (done) break

        buffer += decoder.decode(value, { stream: true })
        const lines = buffer.split('\n')
        buffer = lines.pop() || ''

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = JSON.parse(line.slice(6))

            if (data.conversationId) {
              setConversationId(data.conversationId)
            }

            if (data.text) {
              setMessages(prev => prev.map(m =>
                m.id === assistantId
                  ? { ...m, content: m.content + data.text }
                  : m
              ))
            }

            if (data.products) {
              setMessages(prev => prev.map(m =>
                m.id === assistantId
                  ? { ...m, products: data.products }
                  : m
              ))
            }

            if (data.cartId) {
              setCartId(data.cartId)
            }

            if (data.checkoutUrl) {
              setCheckoutUrl(data.checkoutUrl)
            }
          }
        }
      }
    } catch (error) {
      if ((error as Error).name === 'AbortError') return

      setMessages(prev => prev.map(m =>
        m.id === assistantId
          ? { ...m, content: 'Xin lỗi, đã có lỗi xảy ra. Vui lòng thử lại.' }
          : m
      ))
    } finally {
      setIsLoading(false)
      abortRef.current = null
    }
  }, [config, conversationId, cartId, isLoading])

  const executeAction = useCallback(async (action: ChatAction) => {
    // Checkout: redirect to Shopify
    if (action.type === 'checkout' && action.url) {
      window.top?.location.assign(action.url)  // Break out of iframe
      return
    }

    // Add to cart
    if (action.type === 'add_to_cart' && action.variantId) {
      setIsLoading(true)
      try {
        const response = await fetch(`${config.apiUrl}/api/cart/add`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Tenant-ID': config.tenantId
          },
          body: JSON.stringify({
            variantId: action.variantId,
            cartId
          })
        })
        const data = await response.json()

        if (data.cartId) {
          setCartId(data.cartId)
        }
        if (data.checkoutUrl) {
          setCheckoutUrl(data.checkoutUrl)
        }

        setMessages(prev => [...prev, {
          id: `system-${Date.now()}`,
          role: 'assistant',
          content: 'Đã thêm vào giỏ hàng!',
          actions: data.checkoutUrl ? [{
            type: 'checkout',
            label: 'Thanh toán',
            url: data.checkoutUrl
          }] : undefined
        }])
      } catch {
        setMessages(prev => [...prev, {
          id: `error-${Date.now()}`,
          role: 'assistant',
          content: 'Không thể thêm vào giỏ. Vui lòng thử lại.'
        }])
      } finally {
        setIsLoading(false)
      }
    }
  }, [config, cartId])

  return { messages, isLoading, cartId, checkoutUrl, sendMessage, executeAction }
}
```

### 7. Chat Window Component (Iframe version) (45min)
```tsx
// widget/src/components/ChatWindow.tsx
import { useRef, useEffect } from 'preact/hooks'
import { useChat, Message, ProductCard, ChatAction } from '../hooks/use-chat'
import { MessageInput } from './MessageInput'
import { LoadingDots } from './LoadingDots'
import type { WidgetConfig } from '../App'

interface ChatWindowProps {
  config: WidgetConfig
}

export function ChatWindow({ config }: ChatWindowProps) {
  const { messages, isLoading, checkoutUrl, sendMessage, executeAction } = useChat(config)
  const messagesEndRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })
  }, [messages])

  return (
    <div class="scw-window">
      <header class="scw-header">
        <span>Chat hỗ trợ</span>
        {checkoutUrl && (
          <a href={checkoutUrl} target="_top" class="scw-checkout-link">
            Thanh toán
          </a>
        )}
      </header>

      <div class="scw-messages">
        {messages.map(msg => (
          <MessageBubble
            key={msg.id}
            message={msg}
            onAction={executeAction}
          />
        ))}
        {isLoading && <LoadingDots />}
        <div ref={messagesEndRef} />
      </div>

      <MessageInput onSend={sendMessage} disabled={isLoading} />
    </div>
  )
}

interface MessageBubbleProps {
  message: Message
  onAction: (action: ChatAction) => void
}

function MessageBubble({ message, onAction }: MessageBubbleProps) {
  const isUser = message.role === 'user'

  return (
    <div class={`scw-message ${isUser ? 'scw-user' : 'scw-assistant'}`}>
      <div class="scw-bubble">
        {message.content}
      </div>

      {message.products && message.products.length > 0 && (
        <div class="scw-products">
          {message.products.map(product => (
            <ProductCardComponent
              key={product.id}
              product={product}
              onAddToCart={() => onAction({
                type: 'add_to_cart',
                label: 'Thêm vào giỏ',
                variantId: product.variantId
              })}
            />
          ))}
        </div>
      )}

      {message.actions && message.actions.length > 0 && (
        <div class="scw-actions">
          {message.actions.map((action, i) => (
            <button
              key={i}
              class="scw-action-btn"
              onClick={() => onAction(action)}
            >
              {action.label}
            </button>
          ))}
        </div>
      )}
    </div>
  )
}

interface ProductCardProps {
  product: ProductCard
  onAddToCart: () => void
}

function ProductCardComponent({ product, onAddToCart }: ProductCardProps) {
  return (
    <div class="scw-product-card">
      {product.image && (
        <img src={product.image} alt={product.title} class="scw-product-img" />
      )}
      <div class="scw-product-info">
        <h4 class="scw-product-title">{product.title}</h4>
        <span class="scw-product-price">{product.price}</span>
      </div>
      <button class="scw-add-btn" onClick={onAddToCart}>
        Thêm vào giỏ
      </button>
    </div>
  )
}
```

### 8. Other Components (30min)
```tsx
// widget/src/components/MessageInput.tsx
import { useState, useCallback } from 'preact/hooks'

interface MessageInputProps {
  onSend: (message: string) => void
  disabled: boolean
}

export function MessageInput({ onSend, disabled }: MessageInputProps) {
  const [value, setValue] = useState('')

  const handleSubmit = useCallback((e: Event) => {
    e.preventDefault()
    if (value.trim() && !disabled) {
      onSend(value)
      setValue('')
    }
  }, [value, disabled, onSend])

  return (
    <form class="scw-input-form" onSubmit={handleSubmit}>
      <input
        type="text"
        class="scw-input"
        value={value}
        onInput={(e) => setValue((e.target as HTMLInputElement).value)}
        placeholder="Nhập tin nhắn..."
        disabled={disabled}
      />
      <button
        type="submit"
        class="scw-send-btn"
        disabled={disabled || !value.trim()}
      >
        Gửi
      </button>
    </form>
  )
}
```

```tsx
// widget/src/components/LoadingDots.tsx
export function LoadingDots() {
  return (
    <div class="scw-message scw-assistant">
      <div class="scw-bubble scw-loading">
        <span class="scw-dot"></span>
        <span class="scw-dot"></span>
        <span class="scw-dot"></span>
      </div>
    </div>
  )
}
```

### 9. Widget Styles (Iframe-safe) (30min)
```css
/* widget/src/styles/widget.css */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body, #app {
  height: 100%;
  width: 100%;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

.scw-window {
  height: 100%;
  width: 100%;
  display: flex;
  flex-direction: column;
  background: white;
  border-radius: 16px;
  overflow: hidden;
}

.scw-header {
  padding: 16px;
  background: #3B82F6;
  color: white;
  font-weight: 600;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.scw-checkout-link {
  background: white;
  color: #3B82F6;
  padding: 6px 12px;
  border-radius: 6px;
  text-decoration: none;
  font-size: 13px;
  font-weight: 500;
}

.scw-messages {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.scw-message {
  display: flex;
  flex-direction: column;
  max-width: 85%;
}

.scw-user {
  align-self: flex-end;
}

.scw-assistant {
  align-self: flex-start;
}

.scw-bubble {
  padding: 10px 14px;
  border-radius: 16px;
  line-height: 1.4;
  word-wrap: break-word;
}

.scw-user .scw-bubble {
  background: #3B82F6;
  color: white;
  border-bottom-right-radius: 4px;
}

.scw-assistant .scw-bubble {
  background: #F3F4F6;
  color: #1F2937;
  border-bottom-left-radius: 4px;
}

.scw-loading {
  display: flex;
  gap: 4px;
  padding: 12px 16px;
}

.scw-dot {
  width: 8px;
  height: 8px;
  background: #9CA3AF;
  border-radius: 50%;
  animation: scw-bounce 1.4s infinite ease-in-out;
}

.scw-dot:nth-child(1) { animation-delay: -0.32s; }
.scw-dot:nth-child(2) { animation-delay: -0.16s; }

@keyframes scw-bounce {
  0%, 80%, 100% { transform: scale(0.6); }
  40% { transform: scale(1); }
}

.scw-products {
  display: flex;
  gap: 8px;
  overflow-x: auto;
  padding: 8px 0;
  margin-top: 8px;
}

.scw-product-card {
  min-width: 140px;
  background: white;
  border: 1px solid #E5E7EB;
  border-radius: 8px;
  padding: 8px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.scw-product-img {
  width: 100%;
  height: 80px;
  object-fit: cover;
  border-radius: 4px;
}

.scw-product-title {
  font-size: 13px;
  font-weight: 500;
  color: #1F2937;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.scw-product-price {
  font-size: 14px;
  font-weight: 600;
  color: #3B82F6;
}

.scw-add-btn {
  background: #3B82F6;
  color: white;
  border: none;
  padding: 6px 10px;
  border-radius: 4px;
  font-size: 12px;
  cursor: pointer;
}

.scw-actions {
  display: flex;
  gap: 8px;
  margin-top: 8px;
}

.scw-action-btn {
  background: #10B981;
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 6px;
  font-size: 13px;
  cursor: pointer;
}

.scw-input-form {
  display: flex;
  gap: 8px;
  padding: 12px;
  border-top: 1px solid #E5E7EB;
}

.scw-input {
  flex: 1;
  padding: 10px 14px;
  border: 1px solid #E5E7EB;
  border-radius: 20px;
  outline: none;
  font-size: 14px;
}

.scw-input:focus {
  border-color: #3B82F6;
}

.scw-send-btn {
  background: #3B82F6;
  color: white;
  border: none;
  padding: 10px 16px;
  border-radius: 20px;
  font-size: 14px;
  cursor: pointer;
}

.scw-send-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
```

### 10. Cloudflare Pages Deployment (20min)
```toml
# widget/wrangler.toml
name = "smartchat-widget"
compatibility_date = "2026-02-01"

[site]
bucket = "./dist"
```

```bash
# Deploy to Cloudflare Pages
cd widget
npm run build
npx wrangler pages deploy dist --project-name=smartchat-widget
```

### 11. HTML Template (10min)
```html
<!-- widget/index.html -->
<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Smart Chat Widget</title>
</head>
<body>
  <div id="app"></div>
  <script type="module" src="/src/main.tsx"></script>
</body>
</html>
```

## Todo List
- [ ] Create `widget/public/embed.js` (tiny loader)
- [ ] Initialize widget project with Preact
- [ ] Configure Vite for Cloudflare Pages
- [ ] Create main.tsx (read tenant from URL params)
- [ ] Create App.tsx
- [ ] Create use-chat.ts hook with X-Tenant-ID header
- [ ] Create ChatWindow.tsx
- [ ] Create MessageInput.tsx, LoadingDots.tsx
- [ ] Create widget.css (iframe-safe, full height)
- [ ] Create wrangler.toml for Pages deployment
- [ ] Build and deploy to Cloudflare Pages
- [ ] Test embed script on Next.js site
- [ ] Test embed script on plain HTML page
- [ ] Test checkout redirect breaks out of iframe

## Success Criteria
- Embed script <3KB
- Widget app <100KB gzipped
- Works on Next.js, WordPress, plain HTML
- Chat opens/closes via toggle button
- Messages stream in real-time
- Product cards display with images
- "Add to Cart" works with X-Tenant-ID
- Checkout redirects to Shopify (breaks out of iframe)
- Mobile responsive

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| CORS issues | Medium | High | Configure CORS on API for widget domain |
| Iframe blocked by CSP | Low | High | Document CSP requirements for merchants |
| Checkout redirect blocked | Low | Medium | Use target="_top" or postMessage |
| Style isolation issues | Low | Low | Iframe provides natural isolation |

## Security Considerations
- Iframe provides security isolation from host site
- Validate tenant_id on server side
- Don't expose sensitive data in URL params
- Use HTTPS for all resources
- Sanitize message content (XSS)

## Next Steps
-> [Phase 6: AI Agent Logic](phase-06-ai-agent-logic.md)
</file>

<file path="plans/260215-0133-smart-chatbot-rag/phase-06-ai-agent-logic.md">
# Phase 6: AI Agent Logic

## Context Links
- [Plan Overview](plan.md)
- [Claudible Stealth Bypass](../../claudible-stealth-bypass.md)
- [RAG Architecture Report](../reports/researcher-260215-0128-rag-architecture.md)

## Overview
- **Priority:** P1 - Critical
- **Status:** pending
- **Effort:** 5h

Design system prompts, implement tool calling for actions, and create conversation flow logic for effective sales assistance.

## Key Insights
- Claude Haiku 4.5 supports tool calling via Anthropic API
- System prompt is top-level field (not in messages)
- RAG context should be injected per-turn, not in system prompt
- Actions: search, add to cart, create order

## Requirements

### Functional
- System prompt optimized for sales
- Tool definitions for Shopify actions
- Intent detection (search, purchase, FAQ)
- Context-aware responses
- Conversation memory management

### Non-Functional
- Response latency <2s first token
- Token usage optimization
- Graceful error handling

## Tool Definitions

### Available Tools
```typescript
interface Tool {
  name: string
  description: string
  input_schema: {
    type: 'object'
    properties: Record<string, unknown>
    required: string[]
  }
}

const tools: Tool[] = [
  {
    name: 'search_products',
    description: 'Search for products in the store. Use when customer asks about products, wants recommendations, or mentions a category.',
    input_schema: {
      type: 'object',
      properties: {
        query: {
          type: 'string',
          description: 'Search query - product name, category, or description keywords'
        },
        category: {
          type: 'string',
          description: 'Filter by category (optional)'
        },
        max_price: {
          type: 'number',
          description: 'Maximum price filter (optional)'
        }
      },
      required: ['query']
    }
  },
  {
    name: 'add_to_cart',
    description: 'Add a product to the customer cart. Use when customer explicitly wants to buy or add an item.',
    input_schema: {
      type: 'object',
      properties: {
        product_id: {
          type: 'string',
          description: 'Shopify product ID from search results'
        },
        variant_id: {
          type: 'string',
          description: 'Specific variant ID (required for products with variants)'
        },
        quantity: {
          type: 'number',
          description: 'Number of items to add (default: 1)'
        }
      },
      required: ['variant_id']
    }
  },
  {
    name: 'get_cart',
    description: 'Get current cart contents and total. Use when customer asks about their cart.',
    input_schema: {
      type: 'object',
      properties: {},
      required: []
    }
  },
  {
    name: 'create_order',
    description: 'Create a draft order for the customer. Use for phone/chat orders or when cart is ready.',
    input_schema: {
      type: 'object',
      properties: {
        email: {
          type: 'string',
          description: 'Customer email for order confirmation'
        },
        items: {
          type: 'array',
          description: 'Array of {variant_id, quantity} objects'
        },
        discount_percent: {
          type: 'number',
          description: 'Optional discount percentage'
        }
      },
      required: ['email', 'items']
    }
  },
  {
    name: 'search_faqs',
    description: 'Search FAQs for shipping, returns, policies. Use for non-product questions.',
    input_schema: {
      type: 'object',
      properties: {
        query: {
          type: 'string',
          description: 'Question or topic to search'
        }
      },
      required: ['query']
    }
  }
]
```

## System Prompt

```typescript
// src/prompts/sales-agent.ts
export const SALES_AGENT_SYSTEM_PROMPT = `You are a friendly and helpful sales assistant for an online dropshipping store.

## Your Role
- Help customers find products they're looking for
- Answer questions about products, shipping, and policies
- Assist with purchases and cart management
- Provide personalized recommendations

## Guidelines
1. Be conversational and warm, but efficient
2. Ask clarifying questions when the request is vague
3. Always recommend specific products with prices
4. Proactively suggest related items (upsell gently)
5. If you don't know something, admit it

## Response Format
- Keep responses concise (2-3 sentences max for simple queries)
- Use bullet points for product features
- Include prices when mentioning products
- End with a call-to-action when appropriate

## Tool Usage
- Use search_products for any product-related queries
- Use add_to_cart only when customer explicitly wants to buy
- Use search_faqs for shipping, returns, policy questions
- Use create_order for completing purchases via chat

## Important Rules
- Never make up product information - use search results only
- Always confirm before adding items to cart
- Don't share competitor information
- Be honest about stock availability
- Respect customer privacy

## Example Interactions
Customer: "Do you have any blue t-shirts under $30?"
→ Use search_products with query="blue t-shirt" max_price=30

Customer: "Add that to my cart"
→ Confirm which product, then use add_to_cart

Customer: "What's your return policy?"
→ Use search_faqs with query="return policy"`
```

## Implementation Steps

### 1. Tool Executor Service (1h)
```typescript
// src/services/tool-executor.ts
import { ShopifyStorefrontClient } from './shopify-storefront'
import { ShopifyAdminClient } from './shopify-admin'
import { RAGService } from './rag'

export interface ToolCall {
  id: string
  name: string
  input: Record<string, unknown>
}

export interface ToolResult {
  tool_use_id: string
  content: string
  is_error?: boolean
}

export class ToolExecutor {
  constructor(
    private storefront: ShopifyStorefrontClient,
    private admin: ShopifyAdminClient,
    private rag: RAGService,
    private context: { cartId?: string }
  ) {}

  async execute(toolCall: ToolCall): Promise<ToolResult> {
    try {
      const result = await this.executeInternal(toolCall)
      return {
        tool_use_id: toolCall.id,
        content: JSON.stringify(result)
      }
    } catch (error) {
      return {
        tool_use_id: toolCall.id,
        content: `Error: ${(error as Error).message}`,
        is_error: true
      }
    }
  }

  private async executeInternal(toolCall: ToolCall): Promise<unknown> {
    switch (toolCall.name) {
      case 'search_products': {
        const { query, category, max_price } = toolCall.input as {
          query: string
          category?: string
          max_price?: number
        }
        const results = await this.rag.searchProducts(query, {
          category,
          maxPrice: max_price,
          limit: 5
        })
        return {
          products: results.map(p => ({
            id: p.id,
            shopify_id: p.shopify_id,
            title: p.title,
            price: p.price,
            category: p.category,
            image: p.image_url,
            similarity: p.similarity
          }))
        }
      }

      case 'add_to_cart': {
        const { variant_id, quantity } = toolCall.input as {
          variant_id: string
          quantity?: number
        }

        if (this.context.cartId) {
          const cart = await this.storefront.addToCart(
            this.context.cartId,
            variant_id,
            quantity || 1
          )
          this.context.cartId = cart.id
          return {
            success: true,
            cart_id: cart.id,
            total_items: cart.totalQuantity,
            checkout_url: cart.checkoutUrl
          }
        } else {
          const cart = await this.storefront.createCart(variant_id, quantity || 1)
          this.context.cartId = cart.id
          return {
            success: true,
            cart_id: cart.id,
            total_items: cart.totalQuantity,
            checkout_url: cart.checkoutUrl
          }
        }
      }

      case 'get_cart': {
        if (!this.context.cartId) {
          return { items: [], total_items: 0, message: 'Cart is empty' }
        }
        // Would need to add getCart method to storefront client
        return { cart_id: this.context.cartId, message: 'Cart retrieved' }
      }

      case 'create_order': {
        const { email, items, discount_percent } = toolCall.input as {
          email: string
          items: Array<{ variant_id: string; quantity: number }>
          discount_percent?: number
        }

        const order = await this.admin.createDraftOrder({
          email,
          lineItems: items.map(i => ({
            variantId: i.variant_id,
            quantity: i.quantity
          })),
          discountPercent: discount_percent,
          note: 'Created via chat assistant'
        })

        return {
          success: true,
          order_id: order.id,
          total: order.totalPrice,
          invoice_url: order.invoiceUrl
        }
      }

      case 'search_faqs': {
        const { query } = toolCall.input as { query: string }
        const results = await this.rag.searchFAQs(query, 3)
        return {
          faqs: results.map(f => ({
            question: f.question,
            answer: f.answer
          }))
        }
      }

      default:
        throw new Error(`Unknown tool: ${toolCall.name}`)
    }
  }
}
```

### 2. Agent Orchestrator (1.5h)
```typescript
// src/services/agent.ts
import { ClaudibleClient } from './claudible'
import { ToolExecutor, ToolCall, ToolResult } from './tool-executor'
import { SALES_AGENT_SYSTEM_PROMPT } from '../prompts/sales-agent'
import { tools } from '../prompts/tools'

interface Message {
  role: 'user' | 'assistant'
  content: string | ContentBlock[]
}

interface ContentBlock {
  type: 'text' | 'tool_use' | 'tool_result'
  text?: string
  id?: string
  name?: string
  input?: Record<string, unknown>
  tool_use_id?: string
  content?: string
  is_error?: boolean
}

export class SalesAgent {
  constructor(
    private claudible: ClaudibleClient,
    private toolExecutor: ToolExecutor
  ) {}

  async *chat(
    userMessage: string,
    history: Message[] = []
  ): AsyncGenerator<{
    type: 'text' | 'tool_call' | 'tool_result' | 'products' | 'cart' | 'done'
    data: unknown
  }> {
    const messages: Message[] = [
      ...history,
      { role: 'user', content: userMessage }
    ]

    let continueLoop = true

    while (continueLoop) {
      // Call Claudible with tools
      const response = await this.claudible.chatWithTools(
        messages,
        SALES_AGENT_SYSTEM_PROMPT,
        tools
      )

      // Process response blocks
      const toolCalls: ToolCall[] = []
      let textContent = ''

      for (const block of response.content) {
        if (block.type === 'text') {
          textContent += block.text
          yield { type: 'text', data: block.text }
        } else if (block.type === 'tool_use') {
          toolCalls.push({
            id: block.id!,
            name: block.name!,
            input: block.input!
          })
          yield { type: 'tool_call', data: { name: block.name, input: block.input } }
        }
      }

      // If no tool calls, we're done
      if (toolCalls.length === 0) {
        continueLoop = false
        yield { type: 'done', data: null }
        break
      }

      // Execute tool calls and add results to messages
      const toolResults: ToolResult[] = []
      for (const toolCall of toolCalls) {
        const result = await this.toolExecutor.execute(toolCall)
        toolResults.push(result)

        // Emit special events for UI
        if (toolCall.name === 'search_products') {
          const parsed = JSON.parse(result.content)
          if (parsed.products) {
            yield { type: 'products', data: parsed.products }
          }
        } else if (toolCall.name === 'add_to_cart') {
          const parsed = JSON.parse(result.content)
          if (parsed.success) {
            yield { type: 'cart', data: parsed }
          }
        }

        yield { type: 'tool_result', data: result }
      }

      // Add assistant response and tool results to messages
      messages.push({
        role: 'assistant',
        content: response.content
      })

      messages.push({
        role: 'user',
        content: toolResults.map(r => ({
          type: 'tool_result' as const,
          tool_use_id: r.tool_use_id,
          content: r.content,
          is_error: r.is_error
        }))
      })

      // Continue loop to get final response after tool use
    }
  }
}
```

### 3. Updated Claudible Client with Tools (45min)
```typescript
// src/services/claudible.ts (add method)
interface ToolDefinition {
  name: string
  description: string
  input_schema: Record<string, unknown>
}

interface ChatResponse {
  content: Array<{
    type: 'text' | 'tool_use'
    text?: string
    id?: string
    name?: string
    input?: Record<string, unknown>
  }>
  stop_reason: 'end_turn' | 'tool_use'
  usage: { input_tokens: number; output_tokens: number }
}

async chatWithTools(
  messages: Array<{ role: string; content: unknown }>,
  systemPrompt: string,
  tools: ToolDefinition[]
): Promise<ChatResponse> {
  const response = await fetch(`${this.baseUrl}/messages`, {
    method: 'POST',
    headers: {
      'x-api-key': this.apiKey,
      'anthropic-version': '2023-06-01',
      'Content-Type': 'application/json',
      'X-Claude-Client': 'claude-code/2.1.2',
      'User-Agent': 'claude-code/2.1.2'
    },
    body: JSON.stringify({
      model: this.model,
      max_tokens: this.maxTokens,
      system: systemPrompt,
      tools,
      messages
    })
  })

  if (!response.ok) {
    throw new Error(`Claudible API error: ${response.status}`)
  }

  return response.json()
}
```

### 4. Update Chat Route with Agent (45min)
```typescript
// src/routes/chat.ts (updated)
import { SalesAgent } from '../services/agent'
import { ToolExecutor } from '../services/tool-executor'

chatRoutes.post('/chat/stream', async (c) => {
  const body = await c.req.json<ChatRequest>()

  if (!body.message?.trim()) {
    return c.json({ error: 'Message required' }, 400)
  }

  // Initialize services
  const db = createSupabaseClient(c.env)
  const embeddings = new EmbeddingsService(c.env.OPENAI_API_KEY)
  const rag = new RAGService(db, embeddings)
  const storefront = new ShopifyStorefrontClient({
    storeDomain: c.env.SHOPIFY_STORE_DOMAIN,
    storefrontToken: c.env.SHOPIFY_STOREFRONT_TOKEN
  })
  const admin = new ShopifyAdminClient({
    storeDomain: c.env.SHOPIFY_STORE_DOMAIN,
    adminToken: c.env.SHOPIFY_ADMIN_TOKEN
  })

  const context = { cartId: body.cartId }
  const toolExecutor = new ToolExecutor(storefront, admin, rag, context)
  const claudible = new ClaudibleClient({ apiKey: c.env.CLAUDIBLE_API_KEY })
  const agent = new SalesAgent(claudible, toolExecutor)

  // Get conversation history
  const conversation = new ConversationService(db)
  const history = body.conversationId
    ? await conversation.getHistory(body.conversationId)
    : []

  return streamSSE(c, async (stream) => {
    const conversationId = body.conversationId || await conversation.create(
      body.shopDomain || 'unknown',
      body.customerId
    )

    await stream.writeSSE({
      event: 'start',
      data: JSON.stringify({ conversationId })
    })

    try {
      for await (const event of agent.chat(body.message, history)) {
        switch (event.type) {
          case 'text':
            await stream.writeSSE({
              event: 'delta',
              data: JSON.stringify({ text: event.data })
            })
            break

          case 'products':
            await stream.writeSSE({
              event: 'products',
              data: JSON.stringify({ products: event.data })
            })
            break

          case 'cart':
            await stream.writeSSE({
              event: 'cart',
              data: JSON.stringify(event.data)
            })
            break

          case 'done':
            await stream.writeSSE({
              event: 'done',
              data: JSON.stringify({
                conversationId,
                cartId: context.cartId
              })
            })
            break
        }
      }

      // Save messages to history
      await conversation.addMessage(conversationId, 'user', body.message)
      // Note: Would need to accumulate assistant response

    } catch (error) {
      await stream.writeSSE({
        event: 'error',
        data: JSON.stringify({ error: 'Agent error' })
      })
    }
  })
})
```

### 5. Intent Optimization (30min)
```typescript
// src/services/intent-detector.ts
// Lightweight pre-check before full agent call

export type Intent =
  | 'product_search'
  | 'add_to_cart'
  | 'order_status'
  | 'faq'
  | 'greeting'
  | 'general'

const INTENT_PATTERNS: Record<Intent, RegExp[]> = {
  product_search: [
    /looking for|find me|show me|do you have|searching for/i,
    /any .+\?$/i,
    /recommend|suggest/i
  ],
  add_to_cart: [
    /add .+ to cart|buy .+|purchase|i('ll| will) take/i,
    /want to order|want to buy/i
  ],
  order_status: [
    /where.+order|track.+order|order status/i,
    /delivery|shipping status/i
  ],
  faq: [
    /return policy|shipping|refund|exchange/i,
    /how (long|much)|what is your/i
  ],
  greeting: [
    /^(hi|hello|hey|good morning|good afternoon)/i
  ],
  general: []
}

export function detectIntent(message: string): Intent {
  for (const [intent, patterns] of Object.entries(INTENT_PATTERNS)) {
    for (const pattern of patterns) {
      if (pattern.test(message)) {
        return intent as Intent
      }
    }
  }
  return 'general'
}

// Use to pre-fetch context before agent call
export async function prefetchContext(
  intent: Intent,
  message: string,
  rag: RAGService
): Promise<string> {
  switch (intent) {
    case 'product_search':
      const products = await rag.searchProducts(message, { limit: 3 })
      if (products.length > 0) {
        return `## Quick Product Matches\n${products.map(p =>
          `- ${p.title} ($${p.price})`
        ).join('\n')}`
      }
      return ''

    case 'faq':
      const faqs = await rag.searchFAQs(message, 2)
      if (faqs.length > 0) {
        return `## Relevant FAQs\n${faqs.map(f =>
          `Q: ${f.question}\nA: ${f.answer}`
        ).join('\n\n')}`
      }
      return ''

    default:
      return ''
  }
}
```

## Todo List
- [ ] Create tool definitions in `src/prompts/tools.ts`
- [ ] Create system prompt in `src/prompts/sales-agent.ts`
- [ ] Create `src/services/tool-executor.ts`
- [ ] Create `src/services/agent.ts`
- [ ] Update Claudible client with `chatWithTools` method
- [ ] Update chat route with agent orchestration
- [ ] Create `src/services/intent-detector.ts` (optional optimization)
- [ ] Test tool calling end-to-end
- [ ] Test multi-turn conversations

## Success Criteria
- Agent correctly identifies when to use tools
- Product search returns relevant results
- Add to cart updates cart state
- Multi-turn conversations maintain context
- Error handling is graceful

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Tool call infinite loop | Low | High | Max iteration limit (5 turns) |
| Hallucinated product info | Medium | High | Only show RAG results, never fabricate |
| High token usage | Medium | Medium | Optimize system prompt, cache context |

## Security Considerations
- Validate tool inputs before execution
- Rate limit tool calls per conversation
- Don't expose internal errors to user
- Sanitize tool results before LLM

## Next Steps
→ [Phase 7: Testing & Deployment](phase-07-testing-deployment.md)
</file>

<file path="plans/260215-0133-smart-chatbot-rag/phase-07-testing-deployment.md">
# Phase 7: Testing & Deployment

## Context Links
- [Plan Overview](plan.md)
- [Backend Stack Report](../reports/researcher-260215-0128-backend-stack.md)

## Overview
- **Priority:** P1 - Critical
- **Status:** pending
- **Effort:** 3h

Write tests for critical paths, deploy to Cloudflare Workers, and configure Shopify app for production.

## Key Insights
- Vitest for unit/integration tests (Vite-native)
- Cloudflare Workers has different test environment
- Shopify app requires HTTPS for webhooks
- Secrets managed via wrangler secret

## Requirements

### Functional
- Unit tests for services
- Integration tests for API endpoints
- E2E test for chat flow
- Deployment to Cloudflare Workers
- Shopify app configuration

### Non-Functional
- >80% code coverage for critical paths
- Zero-downtime deployment
- Monitoring and logging

## Test Strategy

### Unit Tests
- `claudible.ts` - API client
- `embeddings.ts` - OpenAI embeddings
- `rag.ts` - Vector search
- `tool-executor.ts` - Tool execution

### Integration Tests
- `/api/chat` - Full chat flow
- `/api/chat/stream` - SSE streaming
- `/shopify/sync` - Product sync

### E2E Tests
- Widget opens/closes
- Send message, receive response
- Product recommendation flow
- Add to cart flow

## Implementation Steps

### 1. Test Setup (20min)
```bash
npm install -D vitest @cloudflare/vitest-pool-workers
```

```typescript
// vitest.config.ts
import { defineWorkersConfig } from '@cloudflare/vitest-pool-workers/config'

export default defineWorkersConfig({
  test: {
    poolOptions: {
      workers: {
        wrangler: { configPath: './wrangler.toml' }
      }
    }
  }
})
```

### 2. Claudible Client Tests (30min)
```typescript
// src/services/__tests__/claudible.test.ts
import { describe, it, expect, vi } from 'vitest'
import { ClaudibleClient } from '../claudible'

describe('ClaudibleClient', () => {
  it('should send correct headers for stealth bypass', async () => {
    const fetchSpy = vi.spyOn(global, 'fetch').mockResolvedValue(
      new Response(JSON.stringify({
        content: [{ type: 'text', text: 'Hello' }],
        usage: { input_tokens: 10, output_tokens: 5 }
      }))
    )

    const client = new ClaudibleClient({ apiKey: 'test-key' })
    await client.chat([{ role: 'user', content: 'Hi' }], 'System prompt')

    expect(fetchSpy).toHaveBeenCalledWith(
      'https://claudible.io/v1/messages',
      expect.objectContaining({
        headers: expect.objectContaining({
          'X-Claude-Client': 'claude-code/2.1.2',
          'User-Agent': 'claude-code/2.1.2',
          'x-api-key': 'test-key'
        })
      })
    )
  })

  it('should extract text from response correctly', async () => {
    vi.spyOn(global, 'fetch').mockResolvedValue(
      new Response(JSON.stringify({
        content: [
          { type: 'text', text: 'Hello ' },
          { type: 'text', text: 'World' }
        ],
        usage: { input_tokens: 10, output_tokens: 5 }
      }))
    )

    const client = new ClaudibleClient({ apiKey: 'test-key' })
    const result = await client.chat([{ role: 'user', content: 'Hi' }], '')

    expect(result).toBe('Hello World')
  })

  it('should place system prompt at top level', async () => {
    const fetchSpy = vi.spyOn(global, 'fetch').mockResolvedValue(
      new Response(JSON.stringify({
        content: [{ type: 'text', text: 'OK' }],
        usage: { input_tokens: 10, output_tokens: 5 }
      }))
    )

    const client = new ClaudibleClient({ apiKey: 'test-key' })
    await client.chat([{ role: 'user', content: 'Hi' }], 'Be helpful')

    const body = JSON.parse(fetchSpy.mock.calls[0][1].body)
    expect(body.system).toBe('Be helpful')
    expect(body.messages).not.toContainEqual(
      expect.objectContaining({ role: 'system' })
    )
  })
})
```

### 3. RAG Service Tests (30min)
```typescript
// src/services/__tests__/rag.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { RAGService } from '../rag'
import { EmbeddingsService } from '../embeddings'

describe('RAGService', () => {
  let mockDb: any
  let mockEmbeddings: EmbeddingsService
  let rag: RAGService

  beforeEach(() => {
    mockEmbeddings = {
      embed: vi.fn().mockResolvedValue(new Array(1536).fill(0.1)),
      embedBatch: vi.fn().mockResolvedValue([
        new Array(1536).fill(0.1),
        new Array(1536).fill(0.2)
      ])
    } as unknown as EmbeddingsService

    mockDb = {
      rpc: vi.fn(),
      from: vi.fn().mockReturnValue({
        upsert: vi.fn().mockResolvedValue({ error: null })
      })
    }

    rag = new RAGService(mockDb, mockEmbeddings)
  })

  it('should search products with filters', async () => {
    mockDb.rpc.mockResolvedValue({
      data: [
        { id: '1', title: 'Blue T-Shirt', price: 25, similarity: 0.85 }
      ],
      error: null
    })

    const results = await rag.searchProducts('blue shirt', {
      maxPrice: 30,
      category: 'clothing'
    })

    expect(mockDb.rpc).toHaveBeenCalledWith('search_products', {
      query_embedding: expect.any(Array),
      match_threshold: 0.5,
      match_count: 5,
      filter_category: 'clothing',
      filter_max_price: 30,
      filter_available: true
    })

    expect(results).toHaveLength(1)
    expect(results[0].title).toBe('Blue T-Shirt')
  })

  it('should build context from products and FAQs', async () => {
    mockDb.rpc
      .mockResolvedValueOnce({
        data: [{ title: 'Product A', price: 10, description: 'Great item' }],
        error: null
      })
      .mockResolvedValueOnce({
        data: [{ question: 'Return policy?', answer: '30 day returns' }],
        error: null
      })

    const context = await rag.buildContext('return policy products')

    expect(context).toContain('Product A')
    expect(context).toContain('$10')
    expect(context).toContain('Return policy?')
    expect(context).toContain('30 day returns')
  })
})
```

### 4. API Integration Tests (30min)
```typescript
// src/__tests__/api.test.ts
import { describe, it, expect, beforeAll } from 'vitest'
import { env, SELF } from 'cloudflare:test'

describe('Chat API', () => {
  it('should return health check', async () => {
    const response = await SELF.fetch('http://localhost/health')
    const data = await response.json()

    expect(response.status).toBe(200)
    expect(data.status).toBe('ok')
  })

  it('should reject empty messages', async () => {
    const response = await SELF.fetch('http://localhost/api/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ message: '' })
    })

    expect(response.status).toBe(400)
    const data = await response.json()
    expect(data.error).toBe('Message required')
  })

  it('should include rate limit headers', async () => {
    const response = await SELF.fetch('http://localhost/api/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ message: 'Hello' })
    })

    expect(response.headers.get('X-RateLimit-Limit')).toBeDefined()
    expect(response.headers.get('X-RateLimit-Remaining')).toBeDefined()
  })
})
```

### 5. Deployment Configuration (20min)
```toml
# wrangler.toml (production)
name = "smart-chat-bot"
main = "src/index.ts"
compatibility_date = "2026-02-01"
compatibility_flags = ["nodejs_compat"]

[env.production]
vars = { ENVIRONMENT = "production" }
routes = [
  { pattern = "chat-api.yourdomain.com/*", zone_name = "yourdomain.com" }
]

# KV for rate limiting (optional)
[[env.production.kv_namespaces]]
binding = "RATE_LIMIT_KV"
id = "xxx"

[observability]
enabled = true
```

### 6. Deployment Scripts (20min)
```json
// package.json scripts
{
  "scripts": {
    "dev": "wrangler dev",
    "test": "vitest",
    "test:coverage": "vitest run --coverage",
    "build": "wrangler deploy --dry-run",
    "deploy": "wrangler deploy",
    "deploy:prod": "wrangler deploy --env production",
    "secrets:set": "wrangler secret put CLAUDIBLE_API_KEY && wrangler secret put SUPABASE_URL && wrangler secret put SUPABASE_ANON_KEY && wrangler secret put OPENAI_API_KEY && wrangler secret put SHOPIFY_STOREFRONT_TOKEN && wrangler secret put SHOPIFY_ADMIN_TOKEN"
  }
}
```

### 7. Set Production Secrets (15min)
```bash
# Set secrets for production
wrangler secret put CLAUDIBLE_API_KEY --env production
wrangler secret put SUPABASE_URL --env production
wrangler secret put SUPABASE_ANON_KEY --env production
wrangler secret put OPENAI_API_KEY --env production
wrangler secret put SHOPIFY_STORE_DOMAIN --env production
wrangler secret put SHOPIFY_STOREFRONT_TOKEN --env production
wrangler secret put SHOPIFY_ADMIN_TOKEN --env production
```

### 8. Deploy to Cloudflare (15min)
```bash
# Build and deploy
npm run deploy:prod

# Verify deployment
curl https://smart-chat-bot.your-subdomain.workers.dev/health
```

### 9. Widget Build & Deploy (15min)
```bash
# Build widget
cd widget
npm run build

# Widget is now in extensions/chat-widget/assets/widget.js
# For Shopify, deploy as Theme App Extension or upload to CDN
```

### 10. Shopify App Configuration (30min)

**Partner Dashboard Setup:**
1. Go to partners.shopify.com
2. Create new app or use existing
3. Configure App URLs:
   - App URL: `https://smart-chat-bot.workers.dev`
   - Allowed redirection URLs: `https://smart-chat-bot.workers.dev/auth/callback`

**API Scopes Required:**
- `read_products` - Product data
- `write_draft_orders` - Create orders
- `read_customers` - Customer info

**Theme App Extension:**
```bash
# In Shopify CLI
shopify app deploy
```

**Webhook Configuration:**
- `products/create` → `/shopify/webhooks/products/update`
- `products/update` → `/shopify/webhooks/products/update`
- `products/delete` → `/shopify/webhooks/products/delete`

## Todo List
- [ ] Install vitest and configure
- [ ] Write Claudible client tests
- [ ] Write RAG service tests
- [ ] Write API integration tests
- [ ] Configure wrangler.toml for production
- [ ] Set production secrets
- [ ] Deploy to Cloudflare Workers
- [ ] Build widget for production
- [ ] Configure Shopify app in Partner Dashboard
- [ ] Deploy Theme App Extension
- [ ] Test end-to-end in Shopify store

## Success Criteria
- All tests pass
- Deployment to Cloudflare successful
- API accessible via custom domain
- Widget loads in Shopify store
- Chat flow works end-to-end
- Webhooks receive product updates

## Monitoring & Observability

### Cloudflare Analytics
- Request count, latency, errors
- Enable in wrangler.toml: `observability.enabled = true`

### Logging
```typescript
// Add structured logging
console.log(JSON.stringify({
  level: 'info',
  event: 'chat_message',
  conversation_id: conversationId,
  duration_ms: Date.now() - startTime
}))
```

### Error Tracking (Optional)
- Sentry for Cloudflare Workers
- Or log errors to Supabase table

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Deployment failure | Low | High | Test with --dry-run first |
| Secret leak | Low | Critical | Use wrangler secret, never commit |
| Shopify app rejection | Medium | Medium | Follow Shopify guidelines |

## Security Checklist
- [ ] All secrets in wrangler secret (not env vars)
- [ ] CORS configured for Shopify domains only
- [ ] Rate limiting enabled
- [ ] Webhook signatures verified
- [ ] No sensitive data in logs
- [ ] HTTPS enforced

## Post-Deployment
1. Monitor first 24 hours for errors
2. Test product sync webhook
3. Verify conversation persistence
4. Check token usage and costs
5. Gather user feedback

## Unresolved Questions
1. Custom domain SSL - using Cloudflare or separate cert?
2. Backup strategy for Supabase data?
3. Staging environment needed?
4. A/B testing for system prompts?
</file>

<file path="plans/260215-0133-smart-chatbot-rag/plan.md">
---
title: "Smart Chat Bot with RAG for Shopify Dropshipping"
description: "Multi-tenant AI chatbot using Claude Haiku 4.5 via Claudible API with RAG for automated sales"
status: pending
priority: P1
effort: 36h
branch: main
tags: [chatbot, rag, shopify, cloudflare-workers, supabase, multi-tenant, iframe]
created: 2026-02-15
---

# Smart Chat Bot with RAG - Implementation Plan

## Overview

Multi-tenant AI-powered sales chatbot with:
- **Multi-tenant**: Up to 15 shops, namespace partitioning, RLS isolation
- **RAG**: 2000+ products per tenant, FAQs, order info via pgvector
- **Actions**: Product search, cart operations, draft order creation
- **Streaming**: SSE via Hono on Cloudflare Workers
- **Widget**: Universal iframe embed (works on ANY website)

## Architecture

```
[Any Website (Next.js / WordPress / Shopify / etc)]
    ↓ embed script tag
[<script src="widget.example.com/chat.js" data-tenant="shop-abc">]
    ↓ creates iframe
[Iframe → Cloudflare Pages (Widget React App)]
    ↓ API calls with X-Tenant-ID header
[Cloudflare Workers (Hono API)]
    ├── SSE Streaming
    ├── Claudible API (Claude Haiku 4.5)
    └── Supabase (PostgreSQL + pgvector + RLS)
         ↓ RLS auto-filters by tenant
[Tenant Config → Shopify APIs per tenant]
    ├── Storefront API (products, cart, checkout)
    └── Admin API (draft orders)
```

## Multi-tenant Design

| Aspect | Implementation |
|--------|----------------|
| Isolation | Row Level Security (RLS) per tenant |
| Identification | `tenant_id` column on all tables |
| Widget Auth | `data-tenant` attribute → X-Tenant-ID header |
| Config Storage | `tenants` table with Shopify credentials |
| Max Tenants | 15 shops (Supabase free tier) |

## Tech Stack

| Layer | Technology |
|-------|------------|
| Backend | Hono on Cloudflare Workers |
| Widget Host | Cloudflare Pages (iframe) |
| Embed Script | Vanilla JS (~2KB) |
| Database | Supabase PostgreSQL + pgvector + RLS |
| Embeddings | OpenAI text-embedding-3-small |
| LLM | Claude Haiku 4.5 via Claudible |
| Shopify | Storefront API + Admin API (per tenant) |

## Phase Summary

| Phase | Description | Effort | Status |
|-------|-------------|--------|--------|
| [Phase 1](phase-01-setup-environment.md) | Project structure, deps, env config | 3h | pending |
| [Phase 2](phase-02-backend-api.md) | Hono API with Claudible, SSE streaming | 5h | pending |
| [Phase 3](phase-03-database-rag.md) | Multi-tenant Supabase, pgvector, RLS, embedding pipeline | 8h | pending |
| [Phase 4](phase-04-shopify-integration.md) | Per-tenant Storefront/Admin API, external site checkout | 6h | pending |
| [Phase 5](phase-05-chat-widget.md) | Universal iframe widget on Cloudflare Pages | 6h | pending |
| [Phase 6](phase-06-ai-agent-logic.md) | Per-tenant system prompts, tool calling, conversation flow | 5h | pending |
| [Phase 7](phase-07-testing-deployment.md) | Tests, Cloudflare deployment, widget embed testing | 3h | pending |

## Key Dependencies

- Claudible API key for Claude Haiku 4.5 access
- Supabase project with pgvector extension
- OpenAI API key for embeddings
- Shopify Partner account (for each tenant's store)
- Cloudflare account for Workers + Pages deployment

## Critical Decisions Made

1. **Multi-tenant with RLS**: Single database, namespace isolation via tenant_id + RLS
2. **Universal Iframe Widget**: Works on ANY website (Next.js, WordPress, Shopify, etc)
3. **pgvector over Qdrant**: Already using Supabase, no chunking needed for products
4. **SSE over WebSocket**: Simpler, better firewall support, sufficient for chat
5. **External checkout flow**: User's main site (Next.js) → redirect to Shopify checkout
6. **Cloudflare Pages for widget**: Fast global CDN, simple deployment

## Reports

- [RAG Architecture](../reports/researcher-260215-0128-rag-architecture.md)
- [Shopify Integration](../reports/researcher-260215-0128-shopify-integration.md)
- [Backend Stack](../reports/researcher-260215-0128-backend-stack.md)
</file>

<file path="src/config/env.ts">
/**
 * Environment configuration with validation for multi-tenant setup
 */

import type { Env } from '../types/index.js';

/**
 * Validates required environment variables
 * @param env - Cloudflare Workers environment bindings
 * @throws Error if required variables are missing
 */
export function validateEnv(env: Env): void {
  const required: (keyof Env)[] = [
    'SUPABASE_URL',
    'SUPABASE_SERVICE_ROLE_KEY',
    'OPENAI_API_KEY',
  ];

  const missing = required.filter((key) => !env[key]);

  if (missing.length > 0) {
    throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
  }
}

/**
 * Gets environment with defaults
 */
export function getEnvConfig(env: Env) {
  return {
    environment: env.ENVIRONMENT || 'development',
    supabaseUrl: env.SUPABASE_URL,
    supabaseKey: env.SUPABASE_SERVICE_ROLE_KEY,
    openaiApiKey: env.OPENAI_API_KEY,
    claudibleApiKey: env.CLAUDIBLE_API_KEY,
    isDevelopment: env.ENVIRONMENT === 'development',
    isProduction: env.ENVIRONMENT === 'production',
  };
}
</file>

<file path="src/config/system-prompts.ts">
/**
 * System prompts configuration for AI sales assistant
 * Supports tenant-specific customization with RAG context injection
 */

/**
 * Default system prompt for sales chatbot
 * Used when tenant has no custom prompt configured
 */
export const DEFAULT_SYSTEM_PROMPT = `You are a helpful sales assistant for an online store.
Your job is to help customers:
- Find products they're looking for
- Answer questions about products and policies
- Help them add items to cart and checkout

Be friendly, concise, and helpful. Use the available tools to search products and manage the cart.
When recommending products, always include prices and key features.
If asked about shipping, returns, or policies, search the FAQs.

IMPORTANT:
- Always search for products before recommending
- Confirm with customer before adding to cart
- Provide checkout link when customer is ready to buy
- If you don't find relevant products, let the customer know and suggest alternatives
- Never make up product information - only use what the tools return`

/**
 * Build complete system prompt combining tenant config and RAG context
 * @param tenantPrompt - Custom prompt from tenant config (may be null)
 * @param ragContext - Context from RAG search results (products/FAQs)
 * @returns Combined system prompt for the AI
 */
export function buildSystemPrompt(
  tenantPrompt: string | null,
  ragContext: string
): string {
  const basePrompt = tenantPrompt ?? DEFAULT_SYSTEM_PROMPT

  if (!ragContext || ragContext.trim().length === 0) {
    return basePrompt
  }

  return `${basePrompt}

---
CONTEXT FROM STORE DATABASE:
${ragContext}
---

Use the above context to answer customer questions when relevant.
If the context doesn't contain needed information, use the search tools.`
}

/**
 * Build prompt suffix for tool usage guidance
 */
export function buildToolGuidance(): string {
  return `
TOOL USAGE GUIDELINES:
- search_products: Use when customer asks about products, looking for items, or needs recommendations
- get_product_details: Use when customer wants more info about a specific product
- add_to_cart: Use ONLY after customer confirms they want to add an item
- get_cart: Use to show customer their current cart or before checkout
- search_faqs: Use for questions about shipping, returns, policies, store info
- create_order: Use when customer provides email and wants to place order`
}
</file>

<file path="src/db/schema.sql">
-- ============================================================================
-- Smart Chat Bot - Multi-tenant Database Schema for Supabase
-- Supports up to 15 tenants (shops) with RLS and pgvector embeddings
-- ============================================================================

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
CREATE EXTENSION IF NOT EXISTS "vector";

-- ============================================================================
-- TABLE: tenants
-- Stores shop/tenant configuration (no RLS - accessed by service role)
-- ============================================================================
CREATE TABLE tenants (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    shopify_store_url TEXT,
    shopify_storefront_token TEXT,
    shopify_admin_token TEXT,
    system_prompt TEXT,
    widget_config JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    CONSTRAINT tenants_id_format CHECK (id ~ '^[a-z0-9-]+$')
);

-- Trigger to auto-update updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tenants_updated_at
    BEFORE UPDATE ON tenants
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- TABLE: products
-- Stores product data with vector embeddings for semantic search
-- ============================================================================
CREATE TABLE products (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id TEXT NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    shopify_product_id TEXT,
    title TEXT NOT NULL,
    description TEXT,
    price DECIMAL(10,2),
    currency TEXT DEFAULT 'USD',
    image_url TEXT,
    category TEXT,
    tags TEXT[],
    embedding vector(1536),
    metadata JSONB DEFAULT '{}'::jsonb,
    synced_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),

    CONSTRAINT products_tenant_shopify_unique UNIQUE (tenant_id, shopify_product_id)
);

-- ============================================================================
-- TABLE: faqs
-- Stores FAQ entries with vector embeddings for semantic search
-- ============================================================================
CREATE TABLE faqs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id TEXT NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    question TEXT NOT NULL,
    answer TEXT NOT NULL,
    category TEXT,
    embedding vector(1536),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================================================
-- TABLE: conversations
-- Tracks chat sessions per tenant
-- ============================================================================
CREATE TABLE conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id TEXT NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    session_id TEXT NOT NULL,
    customer_email TEXT,
    started_at TIMESTAMPTZ DEFAULT NOW(),
    last_message_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb,

    CONSTRAINT conversations_tenant_session_unique UNIQUE (tenant_id, session_id)
);

-- ============================================================================
-- TABLE: messages
-- Stores individual messages within conversations
-- ============================================================================
CREATE TABLE messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    role TEXT NOT NULL,
    content TEXT NOT NULL,
    tool_calls JSONB,
    tokens_used INTEGER,
    created_at TIMESTAMPTZ DEFAULT NOW(),

    CONSTRAINT messages_role_check CHECK (role IN ('user', 'assistant', 'system'))
);

-- ============================================================================
-- ROW LEVEL SECURITY (RLS)
-- Tenant isolation using app.tenant_id session variable
-- ============================================================================

-- Enable RLS on tenant-scoped tables
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
ALTER TABLE faqs ENABLE ROW LEVEL SECURITY;
ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;

-- Products policies
CREATE POLICY products_tenant_isolation ON products
    FOR ALL
    USING (tenant_id = current_setting('app.tenant_id', true))
    WITH CHECK (tenant_id = current_setting('app.tenant_id', true));

-- FAQs policies
CREATE POLICY faqs_tenant_isolation ON faqs
    FOR ALL
    USING (tenant_id = current_setting('app.tenant_id', true))
    WITH CHECK (tenant_id = current_setting('app.tenant_id', true));

-- Conversations policies
CREATE POLICY conversations_tenant_isolation ON conversations
    FOR ALL
    USING (tenant_id = current_setting('app.tenant_id', true))
    WITH CHECK (tenant_id = current_setting('app.tenant_id', true));

-- Messages policies (via conversation's tenant_id)
CREATE POLICY messages_tenant_isolation ON messages
    FOR ALL
    USING (
        EXISTS (
            SELECT 1 FROM conversations c
            WHERE c.id = messages.conversation_id
            AND c.tenant_id = current_setting('app.tenant_id', true)
        )
    )
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM conversations c
            WHERE c.id = messages.conversation_id
            AND c.tenant_id = current_setting('app.tenant_id', true)
        )
    );

-- ============================================================================
-- INDEXES
-- Optimized for multi-tenant queries and vector similarity search
-- ============================================================================

-- Products indexes
CREATE INDEX idx_products_tenant_id ON products(tenant_id);
CREATE INDEX idx_products_tenant_category ON products(tenant_id, category);
CREATE INDEX idx_products_tenant_tags ON products USING GIN(tags);
CREATE INDEX idx_products_synced_at ON products(tenant_id, synced_at);

-- Products vector index (IVFFlat for ~15 tenants with moderate data)
-- Lists = 4 * sqrt(rows_per_tenant) - adjust based on actual data volume
CREATE INDEX idx_products_embedding ON products
    USING ivfflat (embedding vector_cosine_ops)
    WITH (lists = 100);

-- FAQs indexes
CREATE INDEX idx_faqs_tenant_id ON faqs(tenant_id);
CREATE INDEX idx_faqs_tenant_category ON faqs(tenant_id, category);

-- FAQs vector index
CREATE INDEX idx_faqs_embedding ON faqs
    USING ivfflat (embedding vector_cosine_ops)
    WITH (lists = 50);

-- Conversations indexes
CREATE INDEX idx_conversations_tenant_session ON conversations(tenant_id, session_id);
CREATE INDEX idx_conversations_tenant_last_message ON conversations(tenant_id, last_message_at DESC);
CREATE INDEX idx_conversations_customer_email ON conversations(tenant_id, customer_email)
    WHERE customer_email IS NOT NULL;

-- Messages indexes
CREATE INDEX idx_messages_conversation_created ON messages(conversation_id, created_at);

-- ============================================================================
-- FUNCTIONS
-- Vector similarity search functions for products and FAQs
-- ============================================================================

-- Search products by vector similarity
CREATE OR REPLACE FUNCTION search_products(
    query_embedding vector(1536),
    p_tenant_id TEXT,
    p_limit INTEGER DEFAULT 5
)
RETURNS TABLE (
    id UUID,
    shopify_product_id TEXT,
    title TEXT,
    description TEXT,
    price DECIMAL(10,2),
    currency TEXT,
    image_url TEXT,
    category TEXT,
    tags TEXT[],
    metadata JSONB,
    similarity FLOAT
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    RETURN QUERY
    SELECT
        p.id,
        p.shopify_product_id,
        p.title,
        p.description,
        p.price,
        p.currency,
        p.image_url,
        p.category,
        p.tags,
        p.metadata,
        1 - (p.embedding <=> query_embedding) AS similarity
    FROM products p
    WHERE p.tenant_id = p_tenant_id
        AND p.embedding IS NOT NULL
    ORDER BY p.embedding <=> query_embedding
    LIMIT p_limit;
END;
$$;

-- Search FAQs by vector similarity
CREATE OR REPLACE FUNCTION search_faqs(
    query_embedding vector(1536),
    p_tenant_id TEXT,
    p_limit INTEGER DEFAULT 5
)
RETURNS TABLE (
    id UUID,
    question TEXT,
    answer TEXT,
    category TEXT,
    similarity FLOAT
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    RETURN QUERY
    SELECT
        f.id,
        f.question,
        f.answer,
        f.category,
        1 - (f.embedding <=> query_embedding) AS similarity
    FROM faqs f
    WHERE f.tenant_id = p_tenant_id
        AND f.embedding IS NOT NULL
    ORDER BY f.embedding <=> query_embedding
    LIMIT p_limit;
END;
$$;

-- Helper function to set tenant context for RLS
CREATE OR REPLACE FUNCTION set_tenant_context(p_tenant_id TEXT)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    PERFORM set_config('app.tenant_id', p_tenant_id, false);
END;
$$;

-- ============================================================================
-- GRANTS
-- Service role bypasses RLS, anon role uses RLS policies
-- ============================================================================

-- Grant usage on schema
GRANT USAGE ON SCHEMA public TO anon, authenticated, service_role;

-- Grant table permissions
GRANT SELECT ON tenants TO anon, authenticated;
GRANT ALL ON tenants TO service_role;

GRANT SELECT, INSERT, UPDATE, DELETE ON products TO authenticated;
GRANT ALL ON products TO service_role;

GRANT SELECT, INSERT, UPDATE, DELETE ON faqs TO authenticated;
GRANT ALL ON faqs TO service_role;

GRANT SELECT, INSERT, UPDATE, DELETE ON conversations TO authenticated;
GRANT ALL ON conversations TO service_role;

GRANT SELECT, INSERT, UPDATE, DELETE ON messages TO authenticated;
GRANT ALL ON messages TO service_role;

-- Grant function execution
GRANT EXECUTE ON FUNCTION search_products TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION search_faqs TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION set_tenant_context TO authenticated, service_role;

-- ============================================================================
-- COMMENTS
-- Documentation for schema objects
-- ============================================================================

COMMENT ON TABLE tenants IS 'Multi-tenant shop configuration (max 15 tenants)';
COMMENT ON TABLE products IS 'Product catalog with vector embeddings for semantic search';
COMMENT ON TABLE faqs IS 'FAQ entries with vector embeddings for semantic search';
COMMENT ON TABLE conversations IS 'Chat sessions tracked per tenant and browser session';
COMMENT ON TABLE messages IS 'Individual chat messages within conversations';

COMMENT ON FUNCTION search_products IS 'Vector similarity search for products within a tenant';
COMMENT ON FUNCTION search_faqs IS 'Vector similarity search for FAQs within a tenant';
COMMENT ON FUNCTION set_tenant_context IS 'Sets RLS tenant context for current session';
</file>

<file path="src/db/supabase-client.ts">
/**
 * Supabase client with multi-tenant RLS support
 * Uses app.tenant_id session variable for row-level security
 */

import { createClient, SupabaseClient } from '@supabase/supabase-js'

/**
 * Table row types matching schema.sql
 */
export interface TenantRow {
  id: string
  name: string
  shopify_store_url: string | null
  shopify_storefront_token: string | null
  shopify_admin_token: string | null
  system_prompt: string | null
  widget_config: Record<string, unknown>
  created_at: string
  updated_at: string
}

export interface ProductRow {
  id: string
  tenant_id: string
  shopify_product_id: string | null
  title: string
  description: string | null
  price: number | null
  currency: string
  image_url: string | null
  category: string | null
  tags: string[] | null
  embedding: number[] | null
  metadata: Record<string, unknown>
  synced_at: string | null
  created_at: string
}

export interface FaqRow {
  id: string
  tenant_id: string
  question: string
  answer: string
  category: string | null
  embedding: number[] | null
  created_at: string
}

export interface ConversationRow {
  id: string
  tenant_id: string
  session_id: string
  customer_email: string | null
  started_at: string
  last_message_at: string | null
  metadata: Record<string, unknown>
}

export interface MessageRow {
  id: string
  conversation_id: string
  role: 'user' | 'assistant' | 'system'
  content: string
  tool_calls: Record<string, unknown> | null
  tokens_used: number | null
  created_at: string
}

/**
 * RPC function return types
 */
export interface ProductSearchResult {
  id: string
  shopify_product_id: string | null
  title: string
  description: string | null
  price: number | null
  currency: string
  image_url: string | null
  category: string | null
  tags: string[] | null
  metadata: Record<string, unknown>
  similarity: number
}

export interface FaqSearchResult {
  id: string
  question: string
  answer: string
  category: string | null
  similarity: number
}

/**
 * Creates a Supabase client with optional tenant context
 * @param url - Supabase project URL
 * @param key - Supabase service role key (bypasses RLS) or anon key (uses RLS)
 * @param tenantId - Optional tenant ID for RLS context
 */
export function createSupabaseClient(
  url: string,
  key: string,
  tenantId?: string
): SupabaseClient {
  const client = createClient(url, key, {
    auth: {
      autoRefreshToken: false,
      persistSession: false,
    },
    global: {
      headers: tenantId
        ? { 'x-tenant-id': tenantId }
        : {},
    },
  })

  return client
}

/**
 * Sets the tenant context for RLS policies via session variable
 * Must be called before queries that depend on RLS tenant isolation
 * @param client - Supabase client instance
 * @param tenantId - Tenant identifier to set in session
 */
export async function setTenantContext(
  client: SupabaseClient,
  tenantId: string
): Promise<void> {
  const { error } = await client.rpc('set_tenant_context', {
    p_tenant_id: tenantId,
  })

  if (error) {
    throw new Error(`Failed to set tenant context: ${error.message}`)
  }
}

/**
 * Creates a tenant-scoped Supabase client
 * Automatically sets tenant context after creation
 */
export async function createTenantScopedClient(
  url: string,
  key: string,
  tenantId: string
): Promise<SupabaseClient> {
  const client = createSupabaseClient(url, key, tenantId)
  await setTenantContext(client, tenantId)
  return client
}

export type { SupabaseClient }
</file>

<file path="src/index.ts">
/**
 * Smart Chat Bot - Main entry point
 * Hono app with CORS, logging, and tenant middleware
 */

import { Hono } from 'hono';
import { cors } from 'hono/cors';
import { logger } from 'hono/logger';
import type { Env, ContextVariables, ApiResponse } from './types/index.js';
import { chatRoutes } from './routes/chat-routes.js';
import { healthRoutes } from './routes/health-routes.js';

// Create Hono app with typed environment and context variables
const app = new Hono<{ Bindings: Env; Variables: ContextVariables }>();

// CORS middleware - allow all origins for universal widget embedding
app.use(
  '*',
  cors({
    origin: '*',
    allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowHeaders: ['Content-Type', 'Authorization', 'X-Tenant-ID'],
    exposeHeaders: ['Content-Length'],
    maxAge: 86400,
    credentials: false,
  })
);

// Logger middleware
app.use('*', logger());

// Tenant ID extraction middleware
app.use('*', async (c, next) => {
  const tenantId = c.req.header('X-Tenant-ID') || null;
  c.set('tenantId', tenantId);
  await next();
});

// Tenant validation middleware for API routes
// Returns 400 if X-Tenant-ID header is missing
app.use('/api/*', async (c, next) => {
  const tenantId = c.get('tenantId');
  if (!tenantId) {
    const response: ApiResponse<null> = {
      success: false,
      error: 'X-Tenant-ID header is required',
      timestamp: new Date().toISOString(),
    };
    return c.json(response, 400);
  }
  await next();
});

// Mount routes
app.route('/api/chat', chatRoutes);
app.route('/health', healthRoutes);

// Root endpoint
app.get('/', (c) => {
  const response: ApiResponse<{ name: string; version: string }> = {
    success: true,
    data: {
      name: 'Smart Chat Bot API',
      version: '1.0.0',
    },
    timestamp: new Date().toISOString(),
  };
  return c.json(response);
});

// 404 handler
app.notFound((c) => {
  const response: ApiResponse<null> = {
    success: false,
    error: 'Not Found',
    timestamp: new Date().toISOString(),
  };
  return c.json(response, 404);
});

// Error handler
app.onError((err, c) => {
  console.error('Unhandled error:', err);
  const response: ApiResponse<null> = {
    success: false,
    error: c.env.ENVIRONMENT === 'development' ? err.message : 'Internal Server Error',
    timestamp: new Date().toISOString(),
  };
  return c.json(response, 500);
});

export default app;
</file>

<file path="src/routes/chat-routes.ts">
/**
 * Chat API routes with AI agent tool calling support
 * POST /api/chat - SSE streaming chat with agent
 * POST /api/chat/sync - Non-streaming chat (for testing)
 * POST /api/chat/agent - Agent mode with tool calling
 */

import { Hono } from 'hono'
import { streamSSE } from 'hono/streaming'
import type { Env, ContextVariables, ApiResponse } from '../types/index.js'
import {
  ClaudibleClient,
  createClaudibleClient,
  type ChatMessage as ClaudibleChatMessage,
} from '../services/claudible-client.js'
import { createSupabaseClient } from '../db/supabase-client.js'
import { createEmbeddingsService } from '../services/embeddings-service.js'
import { createRagService } from '../services/rag-service.js'
import { createTenantService } from '../services/tenant-service.js'
import { ShopifyFactory } from '../services/shopify-factory.js'
import { createChatAgent, type AgentResponse } from '../services/chat-agent.js'

// Request body types
interface ChatRequest {
  messages: Array<{ role: 'user' | 'assistant'; content: string }>
  sessionId?: string
  systemPrompt?: string
}

interface AgentChatRequest {
  messages: Array<{ role: 'user' | 'assistant'; content: string }>
  sessionId: string
  cartId?: string
}

// Response types
interface ChatSyncResponse {
  reply: string
  usage?: { input_tokens: number; output_tokens: number }
}

const chatRoutes = new Hono<{ Bindings: Env; Variables: ContextVariables }>()

/**
 * Get Claudible client from environment
 */
function getClaudibleClient(env: Env): ClaudibleClient {
  const apiKey = env.CLAUDIBLE_API_KEY
  if (!apiKey) {
    throw new Error('CLAUDIBLE_API_KEY not configured')
  }
  return createClaudibleClient(apiKey)
}

/**
 * Create services for agent mode
 */
function createAgentServices(env: Env) {
  const supabase = createSupabaseClient(env.SUPABASE_URL, env.SUPABASE_SERVICE_ROLE_KEY)
  const embeddings = createEmbeddingsService(env.OPENAI_API_KEY)
  const rag = createRagService(supabase, embeddings)
  const tenantService = createTenantService(supabase)

  return { supabase, embeddings, rag, tenantService }
}

/**
 * POST /api/chat - SSE streaming chat endpoint
 * Streams AI responses as Server-Sent Events
 */
chatRoutes.post('/', async (c) => {
  const tenantId = c.get('tenantId')

  // Parse request body
  let body: ChatRequest
  try {
    body = await c.req.json<ChatRequest>()
  } catch {
    const response: ApiResponse<null> = {
      success: false,
      error: 'Invalid JSON body',
      timestamp: new Date().toISOString(),
    }
    return c.json(response, 400)
  }

  // Validate messages array
  if (!body.messages || !Array.isArray(body.messages) || body.messages.length === 0) {
    const response: ApiResponse<null> = {
      success: false,
      error: 'Messages array is required and must not be empty',
      timestamp: new Date().toISOString(),
    }
    return c.json(response, 400)
  }

  // Validate message structure
  const invalidMessage = body.messages.find(
    (m) => !m.role || !['user', 'assistant'].includes(m.role) || typeof m.content !== 'string'
  )
  if (invalidMessage) {
    const response: ApiResponse<null> = {
      success: false,
      error: 'Invalid message format. Each message must have role (user/assistant) and content (string)',
      timestamp: new Date().toISOString(),
    }
    return c.json(response, 400)
  }

  try {
    const client = getClaudibleClient(c.env)
    const messages = body.messages as ClaudibleChatMessage[]

    // Build system prompt with tenant context
    const systemPrompt =
      body.systemPrompt ||
      `You are a helpful customer support assistant for tenant ${tenantId}. Be concise and helpful.`

    return streamSSE(c, async (stream) => {
      try {
        // Stream chunks from Claudible
        for await (const chunk of client.chatStream(messages, systemPrompt)) {
          await stream.writeSSE({
            event: 'message',
            data: chunk,
          })
        }

        // Send done event
        await stream.writeSSE({
          event: 'done',
          data: '',
        })
      } catch (error) {
        // Send error event
        const errorMessage = error instanceof Error ? error.message : 'Unknown error'
        await stream.writeSSE({
          event: 'error',
          data: JSON.stringify({ error: errorMessage }),
        })
      }
    })
  } catch (error) {
    console.error('Chat streaming error:', error)
    const response: ApiResponse<null> = {
      success: false,
      error: error instanceof Error ? error.message : 'Internal server error',
      timestamp: new Date().toISOString(),
    }
    return c.json(response, 500)
  }
})

/**
 * POST /api/chat/sync - Non-streaming chat endpoint
 * Returns complete response (useful for testing)
 */
chatRoutes.post('/sync', async (c) => {
  const tenantId = c.get('tenantId')

  // Parse request body
  let body: ChatRequest
  try {
    body = await c.req.json<ChatRequest>()
  } catch {
    const response: ApiResponse<null> = {
      success: false,
      error: 'Invalid JSON body',
      timestamp: new Date().toISOString(),
    }
    return c.json(response, 400)
  }

  // Validate messages array
  if (!body.messages || !Array.isArray(body.messages) || body.messages.length === 0) {
    const response: ApiResponse<null> = {
      success: false,
      error: 'Messages array is required and must not be empty',
      timestamp: new Date().toISOString(),
    }
    return c.json(response, 400)
  }

  // Validate message structure
  const invalidMessage = body.messages.find(
    (m) => !m.role || !['user', 'assistant'].includes(m.role) || typeof m.content !== 'string'
  )
  if (invalidMessage) {
    const response: ApiResponse<null> = {
      success: false,
      error: 'Invalid message format. Each message must have role (user/assistant) and content (string)',
      timestamp: new Date().toISOString(),
    }
    return c.json(response, 400)
  }

  try {
    const client = getClaudibleClient(c.env)
    const messages = body.messages as ClaudibleChatMessage[]

    // Build system prompt with tenant context
    const systemPrompt =
      body.systemPrompt ||
      `You are a helpful customer support assistant for tenant ${tenantId}. Be concise and helpful.`

    // Get raw response with usage info
    const rawResponse = await client.chatRaw(messages, systemPrompt)

    // Extract text content
    const reply = rawResponse.content
      .filter((item) => item.type === 'text')
      .map((item) => item.text)
      .join('')

    const response: ApiResponse<ChatSyncResponse> = {
      success: true,
      data: {
        reply,
        usage: rawResponse.usage,
      },
      timestamp: new Date().toISOString(),
    }

    return c.json(response)
  } catch (error) {
    console.error('Chat sync error:', error)
    const response: ApiResponse<null> = {
      success: false,
      error: error instanceof Error ? error.message : 'Internal server error',
      timestamp: new Date().toISOString(),
    }
    return c.json(response, 500)
  }
})

/**
 * POST /api/chat/agent - Agent mode with tool calling
 * Full agent orchestration with RAG, product search, cart management
 */
chatRoutes.post('/agent', async (c) => {
  const tenantId = c.get('tenantId')

  // Parse request body
  let body: AgentChatRequest
  try {
    body = await c.req.json<AgentChatRequest>()
  } catch {
    const response: ApiResponse<null> = {
      success: false,
      error: 'Invalid JSON body',
      timestamp: new Date().toISOString(),
    }
    return c.json(response, 400)
  }

  // Validate messages array
  if (!body.messages || !Array.isArray(body.messages) || body.messages.length === 0) {
    const response: ApiResponse<null> = {
      success: false,
      error: 'Messages array is required and must not be empty',
      timestamp: new Date().toISOString(),
    }
    return c.json(response, 400)
  }

  // Validate sessionId
  if (!body.sessionId) {
    const response: ApiResponse<null> = {
      success: false,
      error: 'sessionId is required for agent mode',
      timestamp: new Date().toISOString(),
    }
    return c.json(response, 400)
  }

  // Validate message structure
  const invalidMessage = body.messages.find(
    (m) => !m.role || !['user', 'assistant'].includes(m.role) || typeof m.content !== 'string'
  )
  if (invalidMessage) {
    const response: ApiResponse<null> = {
      success: false,
      error: 'Invalid message format. Each message must have role (user/assistant) and content (string)',
      timestamp: new Date().toISOString(),
    }
    return c.json(response, 400)
  }

  try {
    // Create services
    const { rag, tenantService } = createAgentServices(c.env)
    const claudible = getClaudibleClient(c.env)
    const apiKey = c.env.CLAUDIBLE_API_KEY!

    // Create agent
    const agent = createChatAgent(claudible, rag, tenantService, ShopifyFactory, apiKey)

    // Process message with agent
    const agentResponse = await agent.processMessage(
      body.messages as ClaudibleChatMessage[],
      {
        tenantId: tenantId!,
        sessionId: body.sessionId,
        cartId: body.cartId,
      }
    )

    const response: ApiResponse<AgentResponse> = {
      success: true,
      data: agentResponse,
      timestamp: new Date().toISOString(),
    }

    return c.json(response)
  } catch (error) {
    console.error('Agent chat error:', error)
    const response: ApiResponse<null> = {
      success: false,
      error: error instanceof Error ? error.message : 'Internal server error',
      timestamp: new Date().toISOString(),
    }
    return c.json(response, 500)
  }
})

/**
 * POST /api/chat/agent/stream - Agent mode with SSE streaming
 * Streams tool calls and text responses
 */
chatRoutes.post('/agent/stream', async (c) => {
  const tenantId = c.get('tenantId')

  // Parse request body
  let body: AgentChatRequest
  try {
    body = await c.req.json<AgentChatRequest>()
  } catch {
    const response: ApiResponse<null> = {
      success: false,
      error: 'Invalid JSON body',
      timestamp: new Date().toISOString(),
    }
    return c.json(response, 400)
  }

  // Validate messages array
  if (!body.messages || !Array.isArray(body.messages) || body.messages.length === 0) {
    const response: ApiResponse<null> = {
      success: false,
      error: 'Messages array is required and must not be empty',
      timestamp: new Date().toISOString(),
    }
    return c.json(response, 400)
  }

  // Validate sessionId
  if (!body.sessionId) {
    const response: ApiResponse<null> = {
      success: false,
      error: 'sessionId is required for agent mode',
      timestamp: new Date().toISOString(),
    }
    return c.json(response, 400)
  }

  try {
    // Create services
    const { rag, tenantService } = createAgentServices(c.env)
    const claudible = getClaudibleClient(c.env)
    const apiKey = c.env.CLAUDIBLE_API_KEY!

    // Create agent
    const agent = createChatAgent(claudible, rag, tenantService, ShopifyFactory, apiKey)

    return streamSSE(c, async (stream) => {
      try {
        // Stream events from agent
        for await (const event of agent.processMessageStream(
          body.messages as ClaudibleChatMessage[],
          {
            tenantId: tenantId!,
            sessionId: body.sessionId,
            cartId: body.cartId,
          }
        )) {
          await stream.writeSSE({
            event: event.type,
            data: JSON.stringify(event.data),
          })
        }
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error'
        await stream.writeSSE({
          event: 'error',
          data: JSON.stringify({ error: errorMessage }),
        })
      }
    })
  } catch (error) {
    console.error('Agent stream error:', error)
    const response: ApiResponse<null> = {
      success: false,
      error: error instanceof Error ? error.message : 'Internal server error',
      timestamp: new Date().toISOString(),
    }
    return c.json(response, 500)
  }
})

export { chatRoutes }
</file>

<file path="src/routes/health-routes.ts">
/**
 * Health check routes for Smart Chat Bot
 * GET /health - Basic health check
 * GET /health/ready - Readiness check with dependency verification
 */

import { Hono } from 'hono';
import type { Env, ContextVariables, ApiResponse } from '../types/index.js';

interface HealthStatus {
  status: 'healthy' | 'unhealthy';
  timestamp: string;
  version: string;
}

interface ReadinessStatus {
  status: 'ready' | 'not_ready';
  timestamp: string;
  checks: {
    kv: 'ok' | 'error';
    claudible: 'ok' | 'error' | 'not_configured';
  };
}

const healthRoutes = new Hono<{ Bindings: Env; Variables: ContextVariables }>();

/**
 * GET /health - Basic liveness check
 * Returns 200 if service is running
 */
healthRoutes.get('/', (c) => {
  const response: ApiResponse<HealthStatus> = {
    success: true,
    data: {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      version: '1.0.0',
    },
    timestamp: new Date().toISOString(),
  };
  return c.json(response);
});

/**
 * GET /health/ready - Readiness check
 * Verifies dependencies (KV, API keys) are available
 */
healthRoutes.get('/ready', async (c) => {
  const checks: ReadinessStatus['checks'] = {
    kv: 'error',
    claudible: 'not_configured',
  };

  // Check KV namespace availability
  try {
    if (c.env.CHAT_SESSIONS) {
      // Test KV with a simple operation
      await c.env.CHAT_SESSIONS.get('__health_check__');
      checks.kv = 'ok';
    }
  } catch {
    checks.kv = 'error';
  }

  // Check Claudible API key configuration
  if (c.env.CLAUDIBLE_API_KEY) {
    checks.claudible = 'ok';
  }

  // Determine overall readiness
  const isReady = checks.kv === 'ok' && checks.claudible === 'ok';

  const response: ApiResponse<ReadinessStatus> = {
    success: isReady,
    data: {
      status: isReady ? 'ready' : 'not_ready',
      timestamp: new Date().toISOString(),
      checks,
    },
    timestamp: new Date().toISOString(),
  };

  return c.json(response, isReady ? 200 : 503);
});

export { healthRoutes };
</file>

<file path="src/services/agent-tools.ts">
/**
 * Agent Tools for AI Sales Chatbot
 * Defines Claude tool_use schema and tool execution logic
 */

import type { RagService } from './rag-service.js'
import type { TenantService } from './tenant-service.js'
import { ShopifyFactory, type CartResponse, type ShopifyProduct } from './shopify-factory.js'

/**
 * Agent execution context with tenant and session info
 */
export interface AgentContext {
  tenantId: string
  sessionId: string
  cartId?: string
}

/**
 * Claude tool_use schema definition
 */
export interface ToolDefinition {
  name: string
  description: string
  input_schema: {
    type: 'object'
    properties: Record<string, { type: string; description: string }>
    required?: string[]
  }
}

/**
 * Tool execution result
 */
export interface ToolResult {
  success: boolean
  data?: unknown
  error?: string
}

/**
 * All available tools for the sales agent
 */
export const AGENT_TOOLS: ToolDefinition[] = [
  {
    name: 'search_products',
    description: 'Search for products in the store by keywords or description',
    input_schema: {
      type: 'object',
      properties: {
        query: { type: 'string', description: 'Search query for finding products' },
        limit: { type: 'number', description: 'Maximum number of results (default 5)' },
      },
      required: ['query'],
    },
  },
  {
    name: 'get_product_details',
    description: 'Get detailed information about a specific product by its handle/slug',
    input_schema: {
      type: 'object',
      properties: {
        productHandle: { type: 'string', description: 'Product handle (URL slug)' },
      },
      required: ['productHandle'],
    },
  },
  {
    name: 'add_to_cart',
    description: 'Add a product variant to the shopping cart',
    input_schema: {
      type: 'object',
      properties: {
        variantId: { type: 'string', description: 'Product variant ID to add' },
        quantity: { type: 'number', description: 'Quantity to add (default 1)' },
      },
      required: ['variantId'],
    },
  },
  {
    name: 'get_cart',
    description: 'Get current shopping cart contents and checkout URL',
    input_schema: {
      type: 'object',
      properties: {},
    },
  },
  {
    name: 'search_faqs',
    description: 'Search FAQ/help articles for customer questions about shipping, returns, policies',
    input_schema: {
      type: 'object',
      properties: {
        query: { type: 'string', description: 'Question or topic to search' },
      },
      required: ['query'],
    },
  },
  {
    name: 'create_order',
    description: 'Create a draft order for the customer (requires customer email)',
    input_schema: {
      type: 'object',
      properties: {
        email: { type: 'string', description: 'Customer email address' },
        note: { type: 'string', description: 'Optional note for the order' },
      },
      required: ['email'],
    },
  },
]

/**
 * Format product for display in chat
 */
function formatProduct(product: ShopifyProduct): Record<string, unknown> {
  const availableVariants = product.variants.filter((v) => v.available)
  return {
    title: product.title,
    handle: product.handle,
    description: product.description?.slice(0, 200) || 'No description',
    price: `$${product.priceRange.minPrice.toFixed(2)}`,
    priceRange:
      product.priceRange.minPrice !== product.priceRange.maxPrice
        ? `$${product.priceRange.minPrice.toFixed(2)} - $${product.priceRange.maxPrice.toFixed(2)}`
        : null,
    image: product.images[0]?.url || null,
    variants: availableVariants.map((v) => ({
      id: v.id,
      title: v.title,
      price: `$${v.price.toFixed(2)}`,
    })),
    inStock: availableVariants.length > 0,
  }
}

/**
 * Format cart response for display
 */
function formatCart(cart: CartResponse): Record<string, unknown> {
  return {
    cartId: cart.cartId,
    checkoutUrl: cart.checkoutUrl,
    itemCount: cart.lines.length,
    items: cart.lines.map((line) => ({
      variantId: line.merchandiseId,
      quantity: line.quantity,
    })),
  }
}

/**
 * Tool executor class - handles execution of all agent tools
 */
export class ToolExecutor {
  private rag: RagService
  private tenantService: TenantService
  private shopifyFactory: typeof ShopifyFactory

  // In-memory cart storage (per session)
  private cartStore: Map<string, string> = new Map()

  constructor(
    rag: RagService,
    tenantService: TenantService,
    shopifyFactory: typeof ShopifyFactory
  ) {
    this.rag = rag
    this.tenantService = tenantService
    this.shopifyFactory = shopifyFactory
  }

  /**
   * Get cart ID for session, with fallback to context
   */
  private getCartId(context: AgentContext): string | undefined {
    const sessionKey = `${context.tenantId}:${context.sessionId}`
    return this.cartStore.get(sessionKey) || context.cartId
  }

  /**
   * Store cart ID for session
   */
  private setCartId(context: AgentContext, cartId: string): void {
    const sessionKey = `${context.tenantId}:${context.sessionId}`
    this.cartStore.set(sessionKey, cartId)
  }

  /**
   * Execute a tool by name with given input
   */
  async execute(
    toolName: string,
    input: Record<string, unknown>,
    context: AgentContext
  ): Promise<ToolResult> {
    try {
      switch (toolName) {
        case 'search_products':
          return await this.searchProducts(input, context)
        case 'get_product_details':
          return await this.getProductDetails(input, context)
        case 'add_to_cart':
          return await this.addToCart(input, context)
        case 'get_cart':
          return await this.getCart(context)
        case 'search_faqs':
          return await this.searchFaqs(input, context)
        case 'create_order':
          return await this.createOrder(input, context)
        default:
          return { success: false, error: `Unknown tool: ${toolName}` }
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Tool execution failed'
      return { success: false, error: message }
    }
  }

  /**
   * Search products using RAG service
   */
  private async searchProducts(
    input: Record<string, unknown>,
    context: AgentContext
  ): Promise<ToolResult> {
    const query = input.query as string
    const limit = (input.limit as number) || 5

    if (!query || query.trim().length === 0) {
      return { success: false, error: 'Search query is required' }
    }

    // Try RAG search first
    const ragResults = await this.rag.searchProducts(context.tenantId, query, limit)

    if (ragResults.length > 0) {
      return {
        success: true,
        data: {
          source: 'database',
          products: ragResults.map((p) => ({
            id: p.id,
            title: p.title,
            description: p.description?.slice(0, 200) || 'No description',
            price: p.price ? `$${p.price.toFixed(2)} ${p.currency}` : 'Price not available',
            image: p.imageUrl,
            category: p.category,
          })),
        },
      }
    }

    // Fallback to Shopify Storefront API
    const tenant = await this.tenantService.getTenant(context.tenantId)
    if (!tenant) {
      return { success: false, error: 'Tenant not found' }
    }

    const storefront = this.shopifyFactory.createStorefrontClient(tenant as any)
    if (!storefront) {
      return { success: true, data: { products: [], message: 'No products found' } }
    }

    const products = await storefront.searchProducts(query, limit)
    return {
      success: true,
      data: {
        source: 'shopify',
        products: products.map(formatProduct),
      },
    }
  }

  /**
   * Get detailed product info by handle
   */
  private async getProductDetails(
    input: Record<string, unknown>,
    context: AgentContext
  ): Promise<ToolResult> {
    const productHandle = input.productHandle as string

    if (!productHandle) {
      return { success: false, error: 'Product handle is required' }
    }

    const tenant = await this.tenantService.getTenant(context.tenantId)
    if (!tenant) {
      return { success: false, error: 'Tenant not found' }
    }

    const storefront = this.shopifyFactory.createStorefrontClient(tenant as any)
    if (!storefront) {
      return { success: false, error: 'Shopify not configured for this store' }
    }

    const product = await storefront.getProduct(productHandle)
    if (!product) {
      return { success: false, error: `Product not found: ${productHandle}` }
    }

    return { success: true, data: formatProduct(product) }
  }

  /**
   * Add item to cart (creates cart if needed)
   */
  private async addToCart(
    input: Record<string, unknown>,
    context: AgentContext
  ): Promise<ToolResult> {
    const variantId = input.variantId as string
    const quantity = (input.quantity as number) || 1

    if (!variantId) {
      return { success: false, error: 'Variant ID is required' }
    }

    const tenant = await this.tenantService.getTenant(context.tenantId)
    if (!tenant) {
      return { success: false, error: 'Tenant not found' }
    }

    const storefront = this.shopifyFactory.createStorefrontClient(tenant as any)
    if (!storefront) {
      return { success: false, error: 'Shopify not configured for this store' }
    }

    const existingCartId = this.getCartId(context)
    let cart: CartResponse

    if (existingCartId) {
      // Add to existing cart
      cart = await storefront.addToCart(existingCartId, [
        { merchandiseId: variantId, quantity },
      ])
    } else {
      // Create new cart
      cart = await storefront.createCart([{ merchandiseId: variantId, quantity }])
      this.setCartId(context, cart.cartId)
    }

    return {
      success: true,
      data: {
        ...formatCart(cart),
        message: `Added ${quantity} item(s) to cart`,
      },
    }
  }

  /**
   * Get current cart contents
   */
  private async getCart(context: AgentContext): Promise<ToolResult> {
    const cartId = this.getCartId(context)

    if (!cartId) {
      return {
        success: true,
        data: { items: [], message: 'Cart is empty' },
      }
    }

    const tenant = await this.tenantService.getTenant(context.tenantId)
    if (!tenant) {
      return { success: false, error: 'Tenant not found' }
    }

    const storefront = this.shopifyFactory.createStorefrontClient(tenant as any)
    if (!storefront) {
      return { success: false, error: 'Shopify not configured' }
    }

    try {
      const cart = await storefront.getCart(cartId)
      return { success: true, data: formatCart(cart) }
    } catch {
      // Cart might have expired
      return { success: true, data: { items: [], message: 'Cart is empty or expired' } }
    }
  }

  /**
   * Search FAQs using RAG service
   */
  private async searchFaqs(
    input: Record<string, unknown>,
    context: AgentContext
  ): Promise<ToolResult> {
    const query = input.query as string

    if (!query || query.trim().length === 0) {
      return { success: false, error: 'Search query is required' }
    }

    const faqs = await this.rag.searchFaqs(context.tenantId, query)

    if (faqs.length === 0) {
      return {
        success: true,
        data: { faqs: [], message: 'No relevant FAQs found' },
      }
    }

    return {
      success: true,
      data: {
        faqs: faqs.map((f) => ({
          question: f.question,
          answer: f.answer,
          category: f.category,
        })),
      },
    }
  }

  /**
   * Create draft order from current cart
   */
  private async createOrder(
    input: Record<string, unknown>,
    context: AgentContext
  ): Promise<ToolResult> {
    const email = input.email as string
    const note = input.note as string | undefined

    if (!email || !email.includes('@')) {
      return { success: false, error: 'Valid email address is required' }
    }

    const cartId = this.getCartId(context)
    if (!cartId) {
      return { success: false, error: 'Cart is empty. Add items before creating order.' }
    }

    const tenant = await this.tenantService.getTenant(context.tenantId)
    if (!tenant) {
      return { success: false, error: 'Tenant not found' }
    }

    // Get cart to extract line items
    const storefront = this.shopifyFactory.createStorefrontClient(tenant as any)
    if (!storefront) {
      return { success: false, error: 'Shopify not configured' }
    }

    const cart = await storefront.getCart(cartId)
    if (cart.lines.length === 0) {
      return { success: false, error: 'Cart is empty' }
    }

    // Create draft order via Admin API
    const admin = this.shopifyFactory.createAdminClient(tenant as any)
    if (!admin) {
      // Fallback to checkout URL if Admin API not configured
      return {
        success: true,
        data: {
          checkoutUrl: cart.checkoutUrl,
          message: 'Please complete your order using the checkout link',
        },
      }
    }

    const draftOrder = await admin.createDraftOrder(
      cart.lines.map((line) => ({
        variantId: line.merchandiseId,
        quantity: line.quantity,
      })),
      email,
      note
    )

    return {
      success: true,
      data: {
        orderId: draftOrder.id,
        invoiceUrl: draftOrder.invoiceUrl,
        totalPrice: draftOrder.totalPrice,
        status: draftOrder.status,
        message: 'Draft order created. Check your email for the invoice.',
      },
    }
  }
}

/**
 * Factory function to create tool executor
 */
export function createToolExecutor(
  rag: RagService,
  tenantService: TenantService,
  shopifyFactory: typeof ShopifyFactory
): ToolExecutor {
  return new ToolExecutor(rag, tenantService, shopifyFactory)
}
</file>

<file path="src/services/chat-agent.ts">
/**
 * Chat Agent - Main orchestration for AI sales assistant
 * Handles message processing with Claude tool_use for multi-step conversations
 */

import type { ClaudibleClient, ChatMessage } from './claudible-client.js'
import type { RagService } from './rag-service.js'
import type { TenantService } from './tenant-service.js'
import { ShopifyFactory } from './shopify-factory.js'
import {
  ToolExecutor,
  AGENT_TOOLS,
  type AgentContext,
  type ToolResult,
} from './agent-tools.js'
import {
  DEFAULT_SYSTEM_PROMPT,
  buildSystemPrompt,
  buildToolGuidance,
} from '../config/system-prompts.js'

const MAX_TOOL_ITERATIONS = 5
const CLAUDIBLE_TOOL_URL = 'https://claudible.io/v1/messages'

/**
 * Tool call from Claude response
 */
interface ToolUseBlock {
  type: 'tool_use'
  id: string
  name: string
  input: Record<string, unknown>
}

/**
 * Text block from Claude response
 */
interface TextBlock {
  type: 'text'
  text: string
}

/**
 * Content block union type
 */
type ContentBlock = ToolUseBlock | TextBlock

/**
 * Claude API response with tool_use
 */
interface ClaudeResponse {
  id: string
  content: ContentBlock[]
  stop_reason: 'end_turn' | 'tool_use' | 'max_tokens'
  usage: { input_tokens: number; output_tokens: number }
}

/**
 * Agent response returned to caller
 */
export interface AgentResponse {
  reply: string
  toolCalls?: Array<{ tool: string; result: ToolResult }>
  cartId?: string
  checkoutUrl?: string
}

/**
 * Stream event types
 */
export type StreamEvent =
  | { type: 'text'; data: string }
  | { type: 'tool'; data: { tool: string; result: ToolResult } }
  | { type: 'done'; data: AgentResponse }
  | { type: 'error'; data: string }

/**
 * Chat Agent class - orchestrates AI conversations with tool calling
 */
export class ChatAgent {
  private claudible: ClaudibleClient
  private rag: RagService
  private tenantService: TenantService
  private toolExecutor: ToolExecutor
  private apiKey: string

  constructor(
    claudible: ClaudibleClient,
    rag: RagService,
    tenantService: TenantService,
    shopifyFactory: typeof ShopifyFactory,
    apiKey: string
  ) {
    this.claudible = claudible
    this.rag = rag
    this.tenantService = tenantService
    this.toolExecutor = new ToolExecutor(rag, tenantService, shopifyFactory)
    this.apiKey = apiKey
  }

  /**
   * Build system prompt with tenant customization and RAG context
   */
  private async buildPrompt(context: AgentContext, userQuery: string): Promise<string> {
    // Get tenant config for custom prompt
    const tenant = await this.tenantService.getTenant(context.tenantId)
    const tenantPrompt = tenant?.systemPrompt ?? null

    // Get RAG context based on user query
    const ragResults = await this.rag.search(context.tenantId, userQuery)
    const ragContext = this.rag.buildContext(ragResults)

    // Combine prompts
    const basePrompt = buildSystemPrompt(tenantPrompt, ragContext)
    const toolGuidance = buildToolGuidance()

    return `${basePrompt}\n${toolGuidance}`
  }

  /**
   * Call Claude API with tool_use support
   */
  private async callClaude(
    messages: ChatMessage[],
    systemPrompt: string
  ): Promise<ClaudeResponse> {
    const response = await fetch(CLAUDIBLE_TOOL_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': this.apiKey,
        'anthropic-version': '2023-06-01',
        'X-Claude-Client': 'claude-code/2.1.2',
        'User-Agent': 'claude-code/2.1.2',
      },
      body: JSON.stringify({
        model: 'claude-haiku-4.5',
        max_tokens: 4096,
        system: systemPrompt,
        messages: messages.map((m) => ({
          role: m.role,
          content: m.content,
        })),
        tools: AGENT_TOOLS,
      }),
    })

    if (!response.ok) {
      const errorText = await response.text()
      throw new Error(`Claude API error: ${response.status} - ${errorText}`)
    }

    return response.json() as Promise<ClaudeResponse>
  }

  /**
   * Call Claude API with tool results
   */
  private async callClaudeWithToolResults(
    messages: Array<{ role: string; content: unknown }>,
    systemPrompt: string
  ): Promise<ClaudeResponse> {
    const response = await fetch(CLAUDIBLE_TOOL_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': this.apiKey,
        'anthropic-version': '2023-06-01',
        'X-Claude-Client': 'claude-code/2.1.2',
        'User-Agent': 'claude-code/2.1.2',
      },
      body: JSON.stringify({
        model: 'claude-haiku-4.5',
        max_tokens: 4096,
        system: systemPrompt,
        messages,
        tools: AGENT_TOOLS,
      }),
    })

    if (!response.ok) {
      const errorText = await response.text()
      throw new Error(`Claude API error: ${response.status} - ${errorText}`)
    }

    return response.json() as Promise<ClaudeResponse>
  }

  /**
   * Extract text content from Claude response
   */
  private extractText(content: ContentBlock[]): string {
    return content
      .filter((block): block is TextBlock => block.type === 'text')
      .map((block) => block.text)
      .join('')
  }

  /**
   * Extract tool use blocks from Claude response
   */
  private extractToolUse(content: ContentBlock[]): ToolUseBlock[] {
    return content.filter((block): block is ToolUseBlock => block.type === 'tool_use')
  }

  /**
   * Process message with tool calling (non-streaming)
   * Handles multi-turn tool use until Claude provides final response
   */
  async processMessage(
    messages: ChatMessage[],
    context: AgentContext
  ): Promise<AgentResponse> {
    // Get last user message for RAG context
    const lastUserMessage = [...messages].reverse().find((m) => m.role === 'user')
    const userQuery = lastUserMessage?.content || ''

    // Build system prompt
    const systemPrompt = await this.buildPrompt(context, userQuery)

    // Track tool calls for response
    const allToolCalls: Array<{ tool: string; result: ToolResult }> = []
    let cartId = context.cartId
    let checkoutUrl: string | undefined

    // Initial Claude call
    let claudeResponse = await this.callClaude(messages, systemPrompt)
    let iterations = 0

    // Build conversation messages for tool use loop
    const conversationMessages: Array<{ role: string; content: unknown }> = messages.map(
      (m) => ({
        role: m.role,
        content: m.content,
      })
    )

    // Loop until Claude stops using tools or max iterations
    while (
      claudeResponse.stop_reason === 'tool_use' &&
      iterations < MAX_TOOL_ITERATIONS
    ) {
      iterations++

      // Get tool use blocks
      const toolUseBlocks = this.extractToolUse(claudeResponse.content)

      // Add assistant message with tool use
      conversationMessages.push({
        role: 'assistant',
        content: claudeResponse.content,
      })

      // Execute each tool and collect results
      const toolResults: Array<{
        type: 'tool_result'
        tool_use_id: string
        content: string
      }> = []

      for (const toolBlock of toolUseBlocks) {
        const result = await this.toolExecutor.execute(
          toolBlock.name,
          toolBlock.input,
          { ...context, cartId }
        )

        allToolCalls.push({ tool: toolBlock.name, result })

        // Extract cart info from results
        if (result.success && result.data) {
          const data = result.data as Record<string, unknown>
          if (data.cartId) cartId = data.cartId as string
          if (data.checkoutUrl) checkoutUrl = data.checkoutUrl as string
        }

        toolResults.push({
          type: 'tool_result',
          tool_use_id: toolBlock.id,
          content: JSON.stringify(result),
        })
      }

      // Add tool results as user message
      conversationMessages.push({
        role: 'user',
        content: toolResults,
      })

      // Call Claude again with tool results
      claudeResponse = await this.callClaudeWithToolResults(
        conversationMessages,
        systemPrompt
      )
    }

    // Extract final text response
    const reply = this.extractText(claudeResponse.content)

    return {
      reply,
      toolCalls: allToolCalls.length > 0 ? allToolCalls : undefined,
      cartId,
      checkoutUrl,
    }
  }

  /**
   * Process message with streaming support
   * Yields events as they occur (text chunks, tool executions, done)
   */
  async *processMessageStream(
    messages: ChatMessage[],
    context: AgentContext
  ): AsyncGenerator<StreamEvent> {
    try {
      // For now, use non-streaming with chunked output
      // Full streaming would require SSE parsing from Claude API
      const response = await this.processMessage(messages, context)

      // Emit tool calls first
      if (response.toolCalls) {
        for (const toolCall of response.toolCalls) {
          yield { type: 'tool', data: toolCall }
        }
      }

      // Emit text in chunks to simulate streaming
      const chunkSize = 50
      for (let i = 0; i < response.reply.length; i += chunkSize) {
        const chunk = response.reply.slice(i, i + chunkSize)
        yield { type: 'text', data: chunk }
      }

      // Emit done event
      yield { type: 'done', data: response }
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Unknown error'
      yield { type: 'error', data: message }
    }
  }
}

/**
 * Factory function to create chat agent
 */
export function createChatAgent(
  claudible: ClaudibleClient,
  rag: RagService,
  tenantService: TenantService,
  shopifyFactory: typeof ShopifyFactory,
  apiKey: string
): ChatAgent {
  return new ChatAgent(claudible, rag, tenantService, shopifyFactory, apiKey)
}

// Re-export types
export type { AgentContext } from './agent-tools.js'
</file>

<file path="src/services/claudible-client.ts">
/**
 * Claudible API Client with stealth headers for Claude Haiku
 * Uses /v1/messages endpoint with stealth bypass
 */

const CLAUDIBLE_BASE_URL = 'https://claudible.io/v1/messages'
const DEFAULT_MODEL = 'claude-haiku-4.5'
const DEFAULT_MAX_TOKENS = 4096
const MAX_RETRIES = 3
const INITIAL_RETRY_DELAY_MS = 1000

// Stealth headers to bypass Claude Code tier restriction
const STEALTH_HEADERS = {
  'X-Claude-Client': 'claude-code/2.1.2',
  'User-Agent': 'claude-code/2.1.2',
}

export interface ClaudibleConfig {
  apiKey: string
  model?: string
  maxTokens?: number
  temperature?: number
}

export interface ChatMessage {
  role: 'user' | 'assistant'
  content: string
}

export interface ClaudibleResponse {
  id: string
  content: Array<{ type: 'text'; text: string }>
  usage: { input_tokens: number; output_tokens: number }
}

interface AnthropicRequestBody {
  model: string
  max_tokens: number
  messages: ChatMessage[]
  system?: string
  temperature?: number
  stream?: boolean
}

interface SSEEvent {
  type: string
  delta?: { type: string; text?: string }
  message?: ClaudibleResponse
}

export class ClaudibleClient {
  private apiKey: string
  private model: string
  private maxTokens: number
  private temperature: number

  constructor(config: ClaudibleConfig) {
    this.apiKey = config.apiKey
    this.model = config.model ?? DEFAULT_MODEL
    this.maxTokens = config.maxTokens ?? DEFAULT_MAX_TOKENS
    this.temperature = config.temperature ?? 0.7
  }

  private getHeaders(): Record<string, string> {
    return {
      'x-api-key': this.apiKey,
      'anthropic-version': '2023-06-01',
      'Content-Type': 'application/json',
      ...STEALTH_HEADERS,
    }
  }

  private buildRequestBody(
    messages: ChatMessage[],
    systemPrompt?: string,
    stream = false
  ): AnthropicRequestBody {
    const body: AnthropicRequestBody = {
      model: this.model,
      max_tokens: this.maxTokens,
      temperature: this.temperature,
      messages,
    }

    if (systemPrompt) {
      body.system = systemPrompt
    }

    if (stream) {
      body.stream = true
    }

    return body
  }

  private async sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms))
  }

  private async fetchWithRetry(
    body: AnthropicRequestBody,
    isStream = false
  ): Promise<Response> {
    let lastError: Error | null = null

    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
      try {
        const response = await fetch(CLAUDIBLE_BASE_URL, {
          method: 'POST',
          headers: this.getHeaders(),
          body: JSON.stringify(body),
        })

        // Rate limit - retry with exponential backoff
        if (response.status === 429) {
          const retryAfter = response.headers.get('Retry-After')
          const delayMs = retryAfter
            ? parseInt(retryAfter, 10) * 1000
            : INITIAL_RETRY_DELAY_MS * Math.pow(2, attempt)

          if (attempt < MAX_RETRIES - 1) {
            await this.sleep(delayMs)
            continue
          }
        }

        // Other errors - don't retry
        if (!response.ok && response.status !== 429) {
          const errorText = await response.text()
          throw new Error(`Claudible API error ${response.status}: ${errorText}`)
        }

        if (response.ok) {
          return response
        }
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error))

        // Don't retry on non-rate-limit errors
        if (!lastError.message.includes('429')) {
          throw lastError
        }

        if (attempt < MAX_RETRIES - 1) {
          await this.sleep(INITIAL_RETRY_DELAY_MS * Math.pow(2, attempt))
        }
      }
    }

    throw lastError ?? new Error('Max retries exceeded')
  }

  /**
   * Non-streaming chat completion
   */
  async chat(messages: ChatMessage[], systemPrompt?: string): Promise<string> {
    const body = this.buildRequestBody(messages, systemPrompt, false)
    const response = await this.fetchWithRetry(body)
    const data = (await response.json()) as ClaudibleResponse

    return data.content
      .filter((c) => c.type === 'text')
      .map((c) => c.text)
      .join('')
  }

  /**
   * Streaming chat completion using SSE
   * Yields text chunks as they arrive
   */
  async *chatStream(
    messages: ChatMessage[],
    systemPrompt?: string
  ): AsyncGenerator<string> {
    const body = this.buildRequestBody(messages, systemPrompt, true)
    const response = await this.fetchWithRetry(body, true)

    if (!response.body) {
      throw new Error('Response body is null')
    }

    const reader = response.body.getReader()
    const decoder = new TextDecoder()
    let buffer = ''

    try {
      while (true) {
        const { done, value } = await reader.read()

        if (done) break

        buffer += decoder.decode(value, { stream: true })

        // Process complete SSE events
        const lines = buffer.split('\n')
        buffer = lines.pop() ?? '' // Keep incomplete line in buffer

        for (const line of lines) {
          if (!line.startsWith('data: ')) continue

          const data = line.slice(6).trim() // Remove 'data: ' prefix

          if (data === '[DONE]') return

          try {
            const event = JSON.parse(data) as SSEEvent

            // Handle content_block_delta events
            if (
              event.type === 'content_block_delta' &&
              event.delta?.type === 'text_delta' &&
              event.delta.text
            ) {
              yield event.delta.text
            }
          } catch {
            // Skip malformed JSON lines
          }
        }
      }
    } finally {
      reader.releaseLock()
    }
  }

  /**
   * Get raw response with full metadata
   */
  async chatRaw(
    messages: ChatMessage[],
    systemPrompt?: string
  ): Promise<ClaudibleResponse> {
    const body = this.buildRequestBody(messages, systemPrompt, false)
    const response = await this.fetchWithRetry(body)
    return response.json() as Promise<ClaudibleResponse>
  }
}

/**
 * Factory function for creating client from environment
 */
export function createClaudibleClient(
  apiKey: string,
  options?: Omit<ClaudibleConfig, 'apiKey'>
): ClaudibleClient {
  return new ClaudibleClient({
    apiKey,
    ...options,
  })
}
</file>

<file path="src/services/embeddings-service.ts">
/**
 * OpenAI Embeddings Service for vector generation
 * Uses text-embedding-3-small model (1536 dimensions)
 */

const OPENAI_EMBEDDINGS_URL = 'https://api.openai.com/v1/embeddings'
const DEFAULT_MODEL = 'text-embedding-3-small'
const MAX_BATCH_SIZE = 100
const MAX_RETRIES = 3
const INITIAL_RETRY_DELAY_MS = 1000

export interface EmbeddingsConfig {
  apiKey: string
  model?: string
}

interface OpenAIEmbeddingResponse {
  object: 'list'
  data: Array<{
    object: 'embedding'
    embedding: number[]
    index: number
  }>
  model: string
  usage: {
    prompt_tokens: number
    total_tokens: number
  }
}

interface OpenAIErrorResponse {
  error: {
    message: string
    type: string
    code: string | null
  }
}

export class EmbeddingsService {
  private apiKey: string
  private model: string

  constructor(config: EmbeddingsConfig) {
    this.apiKey = config.apiKey
    this.model = config.model ?? DEFAULT_MODEL
  }

  private getHeaders(): Record<string, string> {
    return {
      'Authorization': `Bearer ${this.apiKey}`,
      'Content-Type': 'application/json',
    }
  }

  private async sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms))
  }

  private async fetchWithRetry(
    input: string | string[]
  ): Promise<OpenAIEmbeddingResponse> {
    let lastError: Error | null = null

    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
      try {
        const response = await fetch(OPENAI_EMBEDDINGS_URL, {
          method: 'POST',
          headers: this.getHeaders(),
          body: JSON.stringify({
            input,
            model: this.model,
          }),
        })

        // Rate limit - retry with exponential backoff
        if (response.status === 429) {
          const retryAfter = response.headers.get('Retry-After')
          const delayMs = retryAfter
            ? parseInt(retryAfter, 10) * 1000
            : INITIAL_RETRY_DELAY_MS * Math.pow(2, attempt)

          if (attempt < MAX_RETRIES - 1) {
            await this.sleep(delayMs)
            continue
          }
        }

        if (!response.ok) {
          const errorBody = (await response.json()) as OpenAIErrorResponse
          throw new Error(
            `OpenAI Embeddings API error ${response.status}: ${errorBody.error?.message ?? 'Unknown error'}`
          )
        }

        return response.json() as Promise<OpenAIEmbeddingResponse>
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error))

        // Only retry on rate limit or network errors
        const isRetryable =
          lastError.message.includes('429') ||
          lastError.message.includes('fetch')

        if (!isRetryable || attempt >= MAX_RETRIES - 1) {
          throw lastError
        }

        await this.sleep(INITIAL_RETRY_DELAY_MS * Math.pow(2, attempt))
      }
    }

    throw lastError ?? new Error('Max retries exceeded')
  }

  /**
   * Generate embedding vector for a single text
   * @param text - Input text to embed
   * @returns 1536-dimensional embedding vector
   */
  async embed(text: string): Promise<number[]> {
    if (!text || text.trim().length === 0) {
      throw new Error('Text cannot be empty')
    }

    const response = await this.fetchWithRetry(text)
    return response.data[0].embedding
  }

  /**
   * Generate embedding vectors for multiple texts in batch
   * Automatically chunks large batches to stay within API limits
   * @param texts - Array of input texts to embed
   * @returns Array of embedding vectors in same order as input
   */
  async embedBatch(texts: string[]): Promise<number[][]> {
    if (texts.length === 0) {
      return []
    }

    // Filter and validate texts
    const validTexts = texts.map((t, i) => ({
      text: t?.trim() ?? '',
      index: i,
    }))

    const nonEmpty = validTexts.filter((t) => t.text.length > 0)

    if (nonEmpty.length === 0) {
      throw new Error('All texts are empty')
    }

    // Process in chunks
    const results: Array<{ embedding: number[]; index: number }> = []

    for (let i = 0; i < nonEmpty.length; i += MAX_BATCH_SIZE) {
      const chunk = nonEmpty.slice(i, i + MAX_BATCH_SIZE)
      const chunkTexts = chunk.map((t) => t.text)

      const response = await this.fetchWithRetry(chunkTexts)

      // Map results back to original indices
      response.data.forEach((item, responseIndex) => {
        results.push({
          embedding: item.embedding,
          index: chunk[responseIndex].index,
        })
      })
    }

    // Sort by original index and extract embeddings
    results.sort((a, b) => a.index - b.index)
    return results.map((r) => r.embedding)
  }
}

/**
 * Factory function to create embeddings service
 */
export function createEmbeddingsService(
  apiKey: string,
  model?: string
): EmbeddingsService {
  return new EmbeddingsService({ apiKey, model })
}
</file>

<file path="src/services/rag-service.ts">
/**
 * RAG (Retrieval-Augmented Generation) Service
 * Combines vector search for products and FAQs with tenant isolation
 */

import type { SupabaseClient } from '@supabase/supabase-js'
import type { ProductSearchResult, FaqSearchResult } from '../db/supabase-client.js'
import type { EmbeddingsService } from './embeddings-service.js'

const DEFAULT_PRODUCT_LIMIT = 5
const DEFAULT_FAQ_LIMIT = 3
const DEFAULT_SIMILARITY_THRESHOLD = 0.7

export interface ProductResult {
  id: string
  title: string
  description: string | null
  price: number | null
  currency: string
  imageUrl: string | null
  category: string | null
  similarity: number
}

export interface FaqResult {
  question: string
  answer: string
  category: string | null
  similarity: number
}

export interface RagResult {
  products: ProductResult[]
  faqs: FaqResult[]
}

export interface RagConfig {
  productLimit?: number
  faqLimit?: number
  similarityThreshold?: number
}

export class RagService {
  private supabase: SupabaseClient
  private embeddings: EmbeddingsService
  private config: Required<RagConfig>

  constructor(
    supabase: SupabaseClient,
    embeddings: EmbeddingsService,
    config?: RagConfig
  ) {
    this.supabase = supabase
    this.embeddings = embeddings
    this.config = {
      productLimit: config?.productLimit ?? DEFAULT_PRODUCT_LIMIT,
      faqLimit: config?.faqLimit ?? DEFAULT_FAQ_LIMIT,
      similarityThreshold: config?.similarityThreshold ?? DEFAULT_SIMILARITY_THRESHOLD,
    }
  }

  /**
   * Search products by semantic similarity to query
   * Uses search_products RPC function with vector search
   */
  async searchProducts(
    tenantId: string,
    query: string,
    limit?: number
  ): Promise<ProductResult[]> {
    if (!query || query.trim().length === 0) {
      return []
    }

    // Generate query embedding
    const queryEmbedding = await this.embeddings.embed(query)

    // Call search_products RPC
    const { data, error } = await this.supabase.rpc('search_products', {
      query_embedding: queryEmbedding,
      p_tenant_id: tenantId,
      p_limit: limit ?? this.config.productLimit,
    })

    if (error) {
      throw new Error(`Product search failed: ${error.message}`)
    }

    // Filter by similarity threshold and map to result type
    const results = (data ?? []) as ProductSearchResult[]
    return results
      .filter((p) => p.similarity >= this.config.similarityThreshold)
      .map((p) => ({
        id: p.id,
        title: p.title,
        description: p.description,
        price: p.price,
        currency: p.currency,
        imageUrl: p.image_url,
        category: p.category,
        similarity: p.similarity,
      }))
  }

  /**
   * Search FAQs by semantic similarity to query
   * Uses search_faqs RPC function with vector search
   */
  async searchFaqs(
    tenantId: string,
    query: string,
    limit?: number
  ): Promise<FaqResult[]> {
    if (!query || query.trim().length === 0) {
      return []
    }

    // Generate query embedding
    const queryEmbedding = await this.embeddings.embed(query)

    // Call search_faqs RPC
    const { data, error } = await this.supabase.rpc('search_faqs', {
      query_embedding: queryEmbedding,
      p_tenant_id: tenantId,
      p_limit: limit ?? this.config.faqLimit,
    })

    if (error) {
      throw new Error(`FAQ search failed: ${error.message}`)
    }

    // Filter by similarity threshold and map to result type
    const results = (data ?? []) as FaqSearchResult[]
    return results
      .filter((f) => f.similarity >= this.config.similarityThreshold)
      .map((f) => ({
        question: f.question,
        answer: f.answer,
        category: f.category,
        similarity: f.similarity,
      }))
  }

  /**
   * Combined search across products and FAQs
   * Runs both searches in parallel for better performance
   */
  async search(tenantId: string, query: string): Promise<RagResult> {
    if (!query || query.trim().length === 0) {
      return { products: [], faqs: [] }
    }

    // Generate embedding once and use for both searches
    const queryEmbedding = await this.embeddings.embed(query)

    // Run both searches in parallel
    const [productsResult, faqsResult] = await Promise.all([
      this.supabase.rpc('search_products', {
        query_embedding: queryEmbedding,
        p_tenant_id: tenantId,
        p_limit: this.config.productLimit,
      }),
      this.supabase.rpc('search_faqs', {
        query_embedding: queryEmbedding,
        p_tenant_id: tenantId,
        p_limit: this.config.faqLimit,
      }),
    ])

    if (productsResult.error) {
      throw new Error(`Product search failed: ${productsResult.error.message}`)
    }

    if (faqsResult.error) {
      throw new Error(`FAQ search failed: ${faqsResult.error.message}`)
    }

    // Filter and map results
    const productData = (productsResult.data ?? []) as ProductSearchResult[]
    const faqData = (faqsResult.data ?? []) as FaqSearchResult[]

    const products = productData
      .filter((p) => p.similarity >= this.config.similarityThreshold)
      .map((p) => ({
        id: p.id,
        title: p.title,
        description: p.description,
        price: p.price,
        currency: p.currency,
        imageUrl: p.image_url,
        category: p.category,
        similarity: p.similarity,
      }))

    const faqs = faqData
      .filter((f) => f.similarity >= this.config.similarityThreshold)
      .map((f) => ({
        question: f.question,
        answer: f.answer,
        category: f.category,
        similarity: f.similarity,
      }))

    return { products, faqs }
  }

  /**
   * Build context string for LLM prompt from RAG results
   */
  buildContext(results: RagResult): string {
    const sections: string[] = []

    if (results.products.length > 0) {
      const productList = results.products
        .map((p) => {
          const price = p.price ? `$${p.price} ${p.currency}` : 'Price not available'
          return `- ${p.title}: ${p.description ?? 'No description'} (${price})`
        })
        .join('\n')

      sections.push(`**Relevant Products:**\n${productList}`)
    }

    if (results.faqs.length > 0) {
      const faqList = results.faqs
        .map((f) => `Q: ${f.question}\nA: ${f.answer}`)
        .join('\n\n')

      sections.push(`**Relevant FAQs:**\n${faqList}`)
    }

    return sections.join('\n\n')
  }
}

/**
 * Factory function to create RAG service
 */
export function createRagService(
  supabase: SupabaseClient,
  embeddings: EmbeddingsService,
  config?: RagConfig
): RagService {
  return new RagService(supabase, embeddings, config)
}
</file>

<file path="src/services/shopify-admin-client.ts">
/**
 * Shopify Admin API Client (GraphQL)
 * For backend operations: draft orders, order status
 */

const ADMIN_API_VERSION = '2024-01';

export interface AdminConfig {
  storeUrl: string; // xxx.myshopify.com
  adminToken: string; // Admin API access token
}

export interface DraftOrderLine {
  variantId: string;
  quantity: number;
}

export interface DraftOrder {
  id: string;
  invoiceUrl: string;
  totalPrice: string;
  status: string;
}

export interface OrderStatus {
  id: string;
  name: string;
  displayFulfillmentStatus: string;
  trackingUrl: string | null;
  financialStatus: string;
}

interface GraphQLResponse<T> {
  data?: T;
  errors?: Array<{ message: string }>;
}

// GraphQL Mutations and Queries
const CREATE_DRAFT_ORDER_MUTATION = `
  mutation DraftOrderCreate($input: DraftOrderInput!) {
    draftOrderCreate(input: $input) {
      draftOrder {
        id
        invoiceUrl
        totalPrice
        status
      }
      userErrors {
        field
        message
      }
    }
  }
`;

const GET_ORDER_QUERY = `
  query GetOrder($id: ID!) {
    order(id: $id) {
      id
      name
      displayFulfillmentStatus
      financialStatus
      fulfillments(first: 1) {
        trackingInfo {
          url
        }
      }
    }
  }
`;

const GET_DRAFT_ORDER_QUERY = `
  query GetDraftOrder($id: ID!) {
    draftOrder(id: $id) {
      id
      invoiceUrl
      totalPrice
      status
    }
  }
`;

export class ShopifyAdminClient {
  private endpoint: string;
  private headers: Record<string, string>;

  constructor(config: AdminConfig) {
    const cleanUrl = config.storeUrl.replace(/^https?:\/\//, '').replace(/\/$/, '');
    this.endpoint = `https://${cleanUrl}/admin/api/${ADMIN_API_VERSION}/graphql.json`;
    this.headers = {
      'Content-Type': 'application/json',
      'X-Shopify-Access-Token': config.adminToken,
    };
  }

  private async query<T>(query: string, variables?: Record<string, unknown>): Promise<T> {
    const response = await fetch(this.endpoint, {
      method: 'POST',
      headers: this.headers,
      body: JSON.stringify({ query, variables }),
    });

    if (!response.ok) {
      throw new Error(`Shopify Admin API error: ${response.status} ${response.statusText}`);
    }

    const result = (await response.json()) as GraphQLResponse<T>;

    if (result.errors?.length) {
      throw new Error(`GraphQL errors: ${result.errors.map((e) => e.message).join(', ')}`);
    }

    if (!result.data) {
      throw new Error('No data returned from Shopify Admin API');
    }

    return result.data;
  }

  /**
   * Create a draft order for a customer
   * Draft orders can be completed later with payment
   */
  async createDraftOrder(
    lines: DraftOrderLine[],
    email?: string,
    note?: string
  ): Promise<DraftOrder> {
    interface DraftOrderCreateResponse {
      draftOrderCreate: {
        draftOrder: {
          id: string;
          invoiceUrl: string;
          totalPrice: string;
          status: string;
        } | null;
        userErrors: Array<{ field: string; message: string }>;
      };
    }

    const lineItems = lines.map((l) => ({
      variantId: l.variantId,
      quantity: l.quantity,
    }));

    const input: Record<string, unknown> = {
      lineItems,
    };

    if (email) {
      input.email = email;
    }

    if (note) {
      input.note = note;
    }

    const data = await this.query<DraftOrderCreateResponse>(CREATE_DRAFT_ORDER_MUTATION, {
      input,
    });

    if (data.draftOrderCreate.userErrors.length) {
      throw new Error(
        `Draft order creation failed: ${data.draftOrderCreate.userErrors.map((e) => e.message).join(', ')}`
      );
    }

    const draftOrder = data.draftOrderCreate.draftOrder;
    if (!draftOrder) {
      throw new Error('Draft order creation returned null');
    }

    return {
      id: draftOrder.id,
      invoiceUrl: draftOrder.invoiceUrl,
      totalPrice: draftOrder.totalPrice,
      status: draftOrder.status,
    };
  }

  /**
   * Get order status and tracking info
   */
  async getOrder(orderId: string): Promise<OrderStatus> {
    interface GetOrderResponse {
      order: {
        id: string;
        name: string;
        displayFulfillmentStatus: string;
        financialStatus: string;
        fulfillments: Array<{
          trackingInfo: Array<{ url: string | null }>;
        }>;
      } | null;
    }

    const data = await this.query<GetOrderResponse>(GET_ORDER_QUERY, { id: orderId });

    if (!data.order) {
      throw new Error(`Order not found: ${orderId}`);
    }

    const order = data.order;
    const trackingUrl =
      order.fulfillments?.[0]?.trackingInfo?.[0]?.url ?? null;

    return {
      id: order.id,
      name: order.name,
      displayFulfillmentStatus: order.displayFulfillmentStatus,
      financialStatus: order.financialStatus,
      trackingUrl,
    };
  }

  /**
   * Get draft order details
   */
  async getDraftOrder(draftOrderId: string): Promise<DraftOrder> {
    interface GetDraftOrderResponse {
      draftOrder: {
        id: string;
        invoiceUrl: string;
        totalPrice: string;
        status: string;
      } | null;
    }

    const data = await this.query<GetDraftOrderResponse>(GET_DRAFT_ORDER_QUERY, {
      id: draftOrderId,
    });

    if (!data.draftOrder) {
      throw new Error(`Draft order not found: ${draftOrderId}`);
    }

    return {
      id: data.draftOrder.id,
      invoiceUrl: data.draftOrder.invoiceUrl,
      totalPrice: data.draftOrder.totalPrice,
      status: data.draftOrder.status,
    };
  }
}
</file>

<file path="src/services/shopify-factory.ts">
/**
 * Shopify Client Factory for Multi-tenant Setup
 * Creates Storefront and Admin clients based on tenant configuration
 */

import type { TenantConfig } from '../types/index.js';
import { ShopifyStorefrontClient } from './shopify-storefront-client.js';
import { ShopifyAdminClient } from './shopify-admin-client.js';

export class ShopifyFactory {
  /**
   * Create Storefront API client for a tenant
   * Returns null if tenant doesn't have Shopify Storefront credentials
   */
  static createStorefrontClient(tenant: TenantConfig): ShopifyStorefrontClient | null {
    const credentials = tenant.shopifyCredentials;

    if (!credentials?.storeUrl || !credentials?.storefrontToken) {
      return null;
    }

    return new ShopifyStorefrontClient({
      storeUrl: credentials.storeUrl,
      storefrontToken: credentials.storefrontToken,
    });
  }

  /**
   * Create Admin API client for a tenant
   * Returns null if tenant doesn't have Shopify Admin credentials
   */
  static createAdminClient(tenant: TenantConfig): ShopifyAdminClient | null {
    const credentials = tenant.shopifyCredentials;

    if (!credentials?.storeUrl || !credentials?.adminToken) {
      return null;
    }

    return new ShopifyAdminClient({
      storeUrl: credentials.storeUrl,
      adminToken: credentials.adminToken,
    });
  }

  /**
   * Check if tenant has Storefront API configured
   */
  static hasStorefrontAccess(tenant: TenantConfig): boolean {
    const credentials = tenant.shopifyCredentials;
    return Boolean(credentials?.storeUrl && credentials?.storefrontToken);
  }

  /**
   * Check if tenant has Admin API configured
   */
  static hasAdminAccess(tenant: TenantConfig): boolean {
    const credentials = tenant.shopifyCredentials;
    return Boolean(credentials?.storeUrl && credentials?.adminToken);
  }

  /**
   * Create both clients for a tenant (convenience method)
   * Returns object with nullable clients
   */
  static createClients(tenant: TenantConfig): {
    storefront: ShopifyStorefrontClient | null;
    admin: ShopifyAdminClient | null;
  } {
    return {
      storefront: this.createStorefrontClient(tenant),
      admin: this.createAdminClient(tenant),
    };
  }
}

// Re-export types and classes for convenience
export { ShopifyStorefrontClient } from './shopify-storefront-client.js';
export { ShopifyAdminClient } from './shopify-admin-client.js';
export type {
  StorefrontConfig,
  ShopifyProduct,
  CartLine,
  CartResponse,
} from './shopify-storefront-client.js';
export type {
  AdminConfig,
  DraftOrderLine,
  DraftOrder,
  OrderStatus,
} from './shopify-admin-client.js';
</file>

<file path="src/services/shopify-storefront-client.ts">
/**
 * Shopify Storefront API Client (GraphQL)
 * For public operations: product search, cart management
 */

const STOREFRONT_API_VERSION = '2024-01';
const DEFAULT_PRODUCTS_LIMIT = 10;

export interface StorefrontConfig {
  storeUrl: string; // xxx.myshopify.com
  storefrontToken: string;
}

export interface ShopifyProduct {
  id: string;
  title: string;
  handle: string;
  description: string;
  priceRange: { minPrice: number; maxPrice: number };
  images: Array<{ url: string; altText: string }>;
  variants: Array<{ id: string; title: string; price: number; available: boolean }>;
}

export interface CartLine {
  merchandiseId: string; // variant ID
  quantity: number;
}

export interface CartResponse {
  cartId: string;
  checkoutUrl: string;
  lines: CartLine[];
}

interface GraphQLResponse<T> {
  data?: T;
  errors?: Array<{ message: string }>;
}

interface ProductNode {
  id: string;
  title: string;
  handle: string;
  description: string;
  priceRange: {
    minVariantPrice: { amount: string };
    maxVariantPrice: { amount: string };
  };
  images: { edges: Array<{ node: { url: string; altText: string | null } }> };
  variants: {
    edges: Array<{
      node: {
        id: string;
        title: string;
        price: { amount: string };
        availableForSale: boolean;
      };
    }>;
  };
}

// GraphQL Queries
const PRODUCT_FRAGMENT = `
  fragment ProductFields on Product {
    id
    title
    handle
    description
    priceRange {
      minVariantPrice { amount }
      maxVariantPrice { amount }
    }
    images(first: 5) {
      edges {
        node {
          url
          altText
        }
      }
    }
    variants(first: 10) {
      edges {
        node {
          id
          title
          price { amount }
          availableForSale
        }
      }
    }
  }
`;

const SEARCH_PRODUCTS_QUERY = `
  ${PRODUCT_FRAGMENT}
  query SearchProducts($query: String!, $first: Int!) {
    products(first: $first, query: $query) {
      edges {
        node {
          ...ProductFields
        }
      }
    }
  }
`;

const GET_PRODUCT_QUERY = `
  ${PRODUCT_FRAGMENT}
  query GetProduct($handle: String!) {
    product(handle: $handle) {
      ...ProductFields
    }
  }
`;

const CREATE_CART_MUTATION = `
  mutation CartCreate($lines: [CartLineInput!]!) {
    cartCreate(input: { lines: $lines }) {
      cart {
        id
        checkoutUrl
        lines(first: 50) {
          edges {
            node {
              id
              quantity
              merchandise {
                ... on ProductVariant {
                  id
                }
              }
            }
          }
        }
      }
      userErrors {
        field
        message
      }
    }
  }
`;

const ADD_TO_CART_MUTATION = `
  mutation CartLinesAdd($cartId: ID!, $lines: [CartLineInput!]!) {
    cartLinesAdd(cartId: $cartId, lines: $lines) {
      cart {
        id
        checkoutUrl
        lines(first: 50) {
          edges {
            node {
              id
              quantity
              merchandise {
                ... on ProductVariant {
                  id
                }
              }
            }
          }
        }
      }
      userErrors {
        field
        message
      }
    }
  }
`;

const GET_CART_QUERY = `
  query GetCart($cartId: ID!) {
    cart(id: $cartId) {
      id
      checkoutUrl
      lines(first: 50) {
        edges {
          node {
            id
            quantity
            merchandise {
              ... on ProductVariant {
                id
              }
            }
          }
        }
      }
    }
  }
`;

export class ShopifyStorefrontClient {
  private endpoint: string;
  private headers: Record<string, string>;

  constructor(config: StorefrontConfig) {
    const cleanUrl = config.storeUrl.replace(/^https?:\/\//, '').replace(/\/$/, '');
    this.endpoint = `https://${cleanUrl}/api/${STOREFRONT_API_VERSION}/graphql.json`;
    this.headers = {
      'Content-Type': 'application/json',
      'X-Shopify-Storefront-Access-Token': config.storefrontToken,
    };
  }

  private async query<T>(query: string, variables?: Record<string, unknown>): Promise<T> {
    const response = await fetch(this.endpoint, {
      method: 'POST',
      headers: this.headers,
      body: JSON.stringify({ query, variables }),
    });

    if (!response.ok) {
      throw new Error(`Shopify Storefront API error: ${response.status} ${response.statusText}`);
    }

    const result = (await response.json()) as GraphQLResponse<T>;

    if (result.errors?.length) {
      throw new Error(`GraphQL errors: ${result.errors.map((e) => e.message).join(', ')}`);
    }

    if (!result.data) {
      throw new Error('No data returned from Shopify Storefront API');
    }

    return result.data;
  }

  private mapProduct(node: ProductNode): ShopifyProduct {
    return {
      id: node.id,
      title: node.title,
      handle: node.handle,
      description: node.description,
      priceRange: {
        minPrice: parseFloat(node.priceRange.minVariantPrice.amount),
        maxPrice: parseFloat(node.priceRange.maxVariantPrice.amount),
      },
      images: node.images.edges.map((e) => ({
        url: e.node.url,
        altText: e.node.altText ?? '',
      })),
      variants: node.variants.edges.map((e) => ({
        id: e.node.id,
        title: e.node.title,
        price: parseFloat(e.node.price.amount),
        available: e.node.availableForSale,
      })),
    };
  }

  /**
   * Search products by query string
   */
  async searchProducts(query: string, first = DEFAULT_PRODUCTS_LIMIT): Promise<ShopifyProduct[]> {
    interface SearchResponse {
      products: { edges: Array<{ node: ProductNode }> };
    }

    const data = await this.query<SearchResponse>(SEARCH_PRODUCTS_QUERY, {
      query,
      first,
    });

    return data.products.edges.map((e) => this.mapProduct(e.node));
  }

  /**
   * Get single product by handle (URL slug)
   */
  async getProduct(handle: string): Promise<ShopifyProduct | null> {
    interface ProductResponse {
      product: ProductNode | null;
    }

    const data = await this.query<ProductResponse>(GET_PRODUCT_QUERY, { handle });

    return data.product ? this.mapProduct(data.product) : null;
  }

  /**
   * Create a new cart with initial lines
   */
  async createCart(lines: CartLine[]): Promise<CartResponse> {
    interface CartCreateResponse {
      cartCreate: {
        cart: {
          id: string;
          checkoutUrl: string;
          lines: {
            edges: Array<{
              node: { quantity: number; merchandise: { id: string } };
            }>;
          };
        };
        userErrors: Array<{ field: string; message: string }>;
      };
    }

    const cartLines = lines.map((l) => ({
      merchandiseId: l.merchandiseId,
      quantity: l.quantity,
    }));

    const data = await this.query<CartCreateResponse>(CREATE_CART_MUTATION, {
      lines: cartLines,
    });

    if (data.cartCreate.userErrors.length) {
      throw new Error(
        `Cart creation failed: ${data.cartCreate.userErrors.map((e) => e.message).join(', ')}`
      );
    }

    const cart = data.cartCreate.cart;
    return {
      cartId: cart.id,
      checkoutUrl: cart.checkoutUrl,
      lines: cart.lines.edges.map((e) => ({
        merchandiseId: e.node.merchandise.id,
        quantity: e.node.quantity,
      })),
    };
  }

  /**
   * Add lines to existing cart
   */
  async addToCart(cartId: string, lines: CartLine[]): Promise<CartResponse> {
    interface CartLinesAddResponse {
      cartLinesAdd: {
        cart: {
          id: string;
          checkoutUrl: string;
          lines: {
            edges: Array<{
              node: { quantity: number; merchandise: { id: string } };
            }>;
          };
        };
        userErrors: Array<{ field: string; message: string }>;
      };
    }

    const cartLines = lines.map((l) => ({
      merchandiseId: l.merchandiseId,
      quantity: l.quantity,
    }));

    const data = await this.query<CartLinesAddResponse>(ADD_TO_CART_MUTATION, {
      cartId,
      lines: cartLines,
    });

    if (data.cartLinesAdd.userErrors.length) {
      throw new Error(
        `Add to cart failed: ${data.cartLinesAdd.userErrors.map((e) => e.message).join(', ')}`
      );
    }

    const cart = data.cartLinesAdd.cart;
    return {
      cartId: cart.id,
      checkoutUrl: cart.checkoutUrl,
      lines: cart.lines.edges.map((e) => ({
        merchandiseId: e.node.merchandise.id,
        quantity: e.node.quantity,
      })),
    };
  }

  /**
   * Get cart details
   */
  async getCart(cartId: string): Promise<CartResponse> {
    interface GetCartResponse {
      cart: {
        id: string;
        checkoutUrl: string;
        lines: {
          edges: Array<{
            node: { quantity: number; merchandise: { id: string } };
          }>;
        };
      } | null;
    }

    const data = await this.query<GetCartResponse>(GET_CART_QUERY, { cartId });

    if (!data.cart) {
      throw new Error(`Cart not found: ${cartId}`);
    }

    return {
      cartId: data.cart.id,
      checkoutUrl: data.cart.checkoutUrl,
      lines: data.cart.lines.edges.map((e) => ({
        merchandiseId: e.node.merchandise.id,
        quantity: e.node.quantity,
      })),
    };
  }
}
</file>

<file path="src/services/tenant-service.ts">
/**
 * Tenant Service for multi-tenant configuration management
 * Handles tenant lookup and validation with caching
 */

import type { SupabaseClient } from '@supabase/supabase-js'
import type { TenantRow } from '../db/supabase-client.js'

const TENANT_CACHE_TTL_MS = 5 * 60 * 1000 // 5 minutes

export interface TenantConfig {
  id: string
  name: string
  shopifyStoreUrl: string | null
  systemPrompt: string | null
  widgetConfig: Record<string, unknown>
  createdAt: string
  updatedAt: string
}

interface CacheEntry {
  tenant: TenantConfig | null
  expiresAt: number
}

export class TenantService {
  private supabase: SupabaseClient
  private cache: Map<string, CacheEntry>
  private cacheTtl: number

  constructor(supabase: SupabaseClient, cacheTtlMs?: number) {
    this.supabase = supabase
    this.cache = new Map()
    this.cacheTtl = cacheTtlMs ?? TENANT_CACHE_TTL_MS
  }

  /**
   * Get tenant configuration by ID
   * Uses in-memory cache to reduce database calls
   */
  async getTenant(tenantId: string): Promise<TenantConfig | null> {
    if (!tenantId || tenantId.trim().length === 0) {
      return null
    }

    // Check cache
    const cached = this.cache.get(tenantId)
    if (cached && cached.expiresAt > Date.now()) {
      return cached.tenant
    }

    // Fetch from database
    const { data, error } = await this.supabase
      .from('tenants')
      .select('id, name, shopify_store_url, system_prompt, widget_config, created_at, updated_at')
      .eq('id', tenantId)
      .single()

    if (error) {
      // PGRST116 = row not found
      if (error.code === 'PGRST116') {
        this.cache.set(tenantId, {
          tenant: null,
          expiresAt: Date.now() + this.cacheTtl,
        })
        return null
      }
      throw new Error(`Failed to fetch tenant: ${error.message}`)
    }

    // Map to TenantConfig
    const row = data as TenantRow
    const tenant: TenantConfig = {
      id: row.id,
      name: row.name,
      shopifyStoreUrl: row.shopify_store_url,
      systemPrompt: row.system_prompt,
      widgetConfig: row.widget_config,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    }

    // Update cache
    this.cache.set(tenantId, {
      tenant,
      expiresAt: Date.now() + this.cacheTtl,
    })

    return tenant
  }

  /**
   * Validate that a tenant exists and is active
   */
  async validateTenant(tenantId: string): Promise<boolean> {
    const tenant = await this.getTenant(tenantId)
    return tenant !== null
  }

  /**
   * Get system prompt for tenant, with fallback to default
   */
  async getSystemPrompt(tenantId: string, defaultPrompt: string): Promise<string> {
    const tenant = await this.getTenant(tenantId)
    return tenant?.systemPrompt ?? defaultPrompt
  }

  /**
   * Get widget configuration for tenant
   */
  async getWidgetConfig(tenantId: string): Promise<Record<string, unknown>> {
    const tenant = await this.getTenant(tenantId)
    return tenant?.widgetConfig ?? {}
  }

  /**
   * Clear cache for a specific tenant or all tenants
   */
  clearCache(tenantId?: string): void {
    if (tenantId) {
      this.cache.delete(tenantId)
    } else {
      this.cache.clear()
    }
  }

  /**
   * Get all cached tenant IDs (for debugging/monitoring)
   */
  getCachedTenantIds(): string[] {
    const now = Date.now()
    const validIds: string[] = []

    for (const [id, entry] of this.cache.entries()) {
      if (entry.expiresAt > now && entry.tenant !== null) {
        validIds.push(id)
      }
    }

    return validIds
  }
}

/**
 * Factory function to create tenant service
 */
export function createTenantService(
  supabase: SupabaseClient,
  cacheTtlMs?: number
): TenantService {
  return new TenantService(supabase, cacheTtlMs)
}
</file>

<file path="src/types/index.ts">
/**
 * TypeScript types for Smart Chat Bot
 */

/**
 * Cloudflare Workers environment bindings
 */
export interface Env {
  // KV namespaces
  CHAT_SESSIONS: KVNamespace;

  // Environment variables
  ENVIRONMENT: string;
  SUPABASE_URL: string;
  SUPABASE_SERVICE_ROLE_KEY: string;
  OPENAI_API_KEY: string;
  CLAUDIBLE_API_KEY?: string;
}

/**
 * Chat message structure
 */
export interface ChatMessage {
  id: string;
  tenantId: string;
  sessionId: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: string;
  metadata?: Record<string, unknown>;
}

/**
 * Shopify credentials for a tenant
 */
export interface ShopifyCredentials {
  storeUrl: string; // xxx.myshopify.com
  storefrontToken?: string; // Public Storefront API token
  adminToken?: string; // Admin API access token (backend only)
}

/**
 * Tenant configuration for multi-tenant setup
 */
export interface TenantConfig {
  id: string;
  name: string;
  shopifyDomain?: string;
  shopifyCredentials?: ShopifyCredentials;
  widgetSettings: WidgetSettings;
  ragConfig: RagConfig;
  createdAt: string;
  updatedAt: string;
}

/**
 * Widget customization settings
 */
export interface WidgetSettings {
  primaryColor: string;
  position: 'bottom-right' | 'bottom-left';
  greeting: string;
  placeholder: string;
  brandLogo?: string;
}

/**
 * RAG (Retrieval-Augmented Generation) configuration
 */
export interface RagConfig {
  enabled: boolean;
  collectionName: string;
  maxResults: number;
  similarityThreshold: number;
}

/**
 * Chat session data
 */
export interface ChatSession {
  id: string;
  tenantId: string;
  visitorId: string;
  messages: ChatMessage[];
  createdAt: string;
  lastActiveAt: string;
}

/**
 * API response wrapper
 */
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  timestamp: string;
}

/**
 * Hono context variables
 */
export interface ContextVariables {
  tenantId: string | null;
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "bundler",
    "strict": true,
    "lib": ["ES2022"],
    "types": ["@cloudflare/workers-types"],
    "skipLibCheck": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "outDir": "dist",
    "rootDir": "src"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "widget"]
}
</file>

<file path="widget/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat Widget</title>
</head>
<body>
  <div id="app"></div>
  <script type="module" src="/src/main.tsx"></script>
</body>
</html>
</file>

<file path="widget/package.json">
{
  "name": "smart-chat-widget",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "preact": "^10.25.0"
  },
  "devDependencies": {
    "@preact/preset-vite": "^2.9.0",
    "vite": "^6.0.0",
    "typescript": "^5.7.0"
  }
}
</file>

<file path="widget/public/embed.js">
// embed.js - Include on any website
// Usage: <script src="https://widget.example.com/embed.js" data-tenant="shop-abc"></script>
(function() {
  'use strict';

  var script = document.currentScript;
  if (!script) return;

  var tenant = script.getAttribute('data-tenant') || '';
  var position = script.getAttribute('data-position') || 'bottom-right';
  var apiUrl = script.getAttribute('data-api') || '';
  var widgetUrl = script.getAttribute('data-widget-url') || script.src.replace('/embed.js', '/');

  // Build iframe URL
  var iframeSrc = widgetUrl + '?tenant=' + encodeURIComponent(tenant);
  if (apiUrl) {
    iframeSrc += '&api=' + encodeURIComponent(apiUrl);
  }

  // Create toggle button
  var toggleBtn = document.createElement('button');
  toggleBtn.id = 'smart-chat-toggle';
  toggleBtn.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>';
  toggleBtn.setAttribute('aria-label', 'Open chat');

  var btnPosition = position === 'bottom-left' ? 'left: 20px;' : 'right: 20px;';
  toggleBtn.style.cssText = 'position: fixed; ' + btnPosition + ' bottom: 20px; width: 56px; height: 56px; border-radius: 50%; background: #2563eb; color: white; border: none; cursor: pointer; box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4); z-index: 9998; display: flex; align-items: center; justify-content: center; transition: transform 0.2s, box-shadow 0.2s;';

  // Create iframe container
  var container = document.createElement('div');
  container.id = 'smart-chat-container';

  var containerPosition = position === 'bottom-left' ? 'left: 20px;' : 'right: 20px;';
  container.style.cssText = 'position: fixed; ' + containerPosition + ' bottom: 90px; width: 380px; height: 550px; max-height: calc(100vh - 120px); border: none; border-radius: 12px; box-shadow: 0 4px 24px rgba(0, 0, 0, 0.15); z-index: 9999; overflow: hidden; display: none; background: white;';

  // Create iframe
  var iframe = document.createElement('iframe');
  iframe.src = iframeSrc;
  iframe.style.cssText = 'width: 100%; height: 100%; border: none;';
  iframe.setAttribute('allow', 'clipboard-write');
  iframe.setAttribute('loading', 'lazy');

  container.appendChild(iframe);

  // State
  var isOpen = false;

  // Toggle function
  function toggleChat() {
    isOpen = !isOpen;
    container.style.display = isOpen ? 'block' : 'none';
    toggleBtn.innerHTML = isOpen
      ? '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>'
      : '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>';
    toggleBtn.setAttribute('aria-label', isOpen ? 'Close chat' : 'Open chat');
  }

  toggleBtn.addEventListener('click', toggleChat);

  // Hover effect
  toggleBtn.addEventListener('mouseenter', function() {
    this.style.transform = 'scale(1.05)';
    this.style.boxShadow = '0 6px 16px rgba(37, 99, 235, 0.5)';
  });

  toggleBtn.addEventListener('mouseleave', function() {
    this.style.transform = 'scale(1)';
    this.style.boxShadow = '0 4px 12px rgba(37, 99, 235, 0.4)';
  });

  // Mobile responsive
  function handleResize() {
    if (window.innerWidth < 420) {
      container.style.width = 'calc(100vw - 20px)';
      container.style.left = '10px';
      container.style.right = '10px';
      container.style.bottom = '80px';
    } else {
      container.style.width = '380px';
      container.style.left = position === 'bottom-left' ? '20px' : '';
      container.style.right = position === 'bottom-right' ? '20px' : '';
      container.style.bottom = '90px';
    }
  }

  window.addEventListener('resize', handleResize);
  handleResize();

  // Append to DOM
  document.body.appendChild(toggleBtn);
  document.body.appendChild(container);

  // Expose API
  window.SmartChatWidget = {
    open: function() { if (!isOpen) toggleChat(); },
    close: function() { if (isOpen) toggleChat(); },
    toggle: toggleChat,
    isOpen: function() { return isOpen; }
  };
})();
</file>

<file path="widget/src/app.tsx">
import { useRef, useEffect } from 'preact/hooks'
import { useChat } from './hooks/use-chat'
import { ChatMessages } from './components/chat-messages'
import { ChatInput } from './components/chat-input'
import { CartButton } from './components/cart-button'

interface AppProps {
  tenantId: string
  apiUrl: string
}

export function App({ tenantId, apiUrl }: AppProps) {
  const messagesEndRef = useRef<HTMLDivElement>(null)

  const {
    messages,
    isLoading,
    cartId,
    checkoutUrl,
    sendMessage,
    clearMessages
  } = useChat({ apiUrl, tenantId })

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })
  }, [messages])

  const handleClearChat = () => {
    if (confirm('Bạn có muốn xóa cuộc trò chuyện?')) {
      clearMessages()
    }
  }

  return (
    <div class="chat-widget">
      <header class="chat-header">
        <div class="chat-header-info">
          <div class="chat-avatar">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" />
            </svg>
          </div>
          <div class="chat-title">
            <h1>Hỗ trợ mua hàng</h1>
            <span class="chat-status">Trực tuyến</span>
          </div>
        </div>
        <div class="chat-header-actions">
          {checkoutUrl && (
            <CartButton
              itemCount={cartId ? 1 : 0}
              checkoutUrl={checkoutUrl}
            />
          )}
          <button
            class="chat-clear-button"
            onClick={handleClearChat}
            title="Xóa cuộc trò chuyện"
          >
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="3 6 5 6 21 6" />
              <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
            </svg>
          </button>
        </div>
      </header>

      <main class="chat-body">
        <ChatMessages messages={messages} isLoading={isLoading} />
        <div ref={messagesEndRef} />
      </main>

      <footer class="chat-footer">
        <ChatInput
          onSend={sendMessage}
          disabled={isLoading}
          placeholder="Nhập tin nhắn của bạn..."
        />
      </footer>
    </div>
  )
}
</file>

<file path="widget/src/components/cart-button.tsx">
interface CartButtonProps {
  itemCount: number
  checkoutUrl: string | null
  onClick?: () => void
}

export function CartButton({ itemCount, checkoutUrl, onClick }: CartButtonProps) {
  if (!checkoutUrl && itemCount === 0) return null

  const handleClick = () => {
    if (checkoutUrl) {
      window.open(checkoutUrl, '_blank', 'noopener,noreferrer')
    }
    onClick?.()
  }

  return (
    <button class="cart-button" onClick={handleClick}>
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="9" cy="21" r="1" />
        <circle cx="20" cy="21" r="1" />
        <path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6" />
      </svg>
      {itemCount > 0 && <span class="cart-badge">{itemCount}</span>}
      <span class="cart-text">
        {checkoutUrl ? 'Thanh toán' : 'Giỏ hàng'}
      </span>
    </button>
  )
}
</file>

<file path="widget/src/components/chat-bubble.tsx">
import type { Message } from '../types'
import { ProductCard } from './product-card'

interface ChatBubbleProps {
  message: Message
}

export function ChatBubble({ message }: ChatBubbleProps) {
  const isUser = message.role === 'user'

  return (
    <div class={`chat-bubble-wrapper ${isUser ? 'user' : 'assistant'}`}>
      <div class={`chat-bubble ${isUser ? 'user' : 'assistant'}`}>
        {message.content ? (
          <div class="chat-bubble-content">{message.content}</div>
        ) : (
          <div class="chat-bubble-loading">...</div>
        )}
      </div>

      {message.products && message.products.length > 0 && (
        <div class="product-cards">
          {message.products.map(product => (
            <ProductCard key={product.id} product={product} />
          ))}
        </div>
      )}
    </div>
  )
}
</file>

<file path="widget/src/components/chat-input.tsx">
import { useState, useRef } from 'preact/hooks'

interface ChatInputProps {
  onSend: (message: string) => void
  disabled: boolean
  placeholder?: string
}

export function ChatInput({ onSend, disabled, placeholder = 'Nhập tin nhắn...' }: ChatInputProps) {
  const [value, setValue] = useState('')
  const inputRef = useRef<HTMLTextAreaElement>(null)

  const handleSubmit = () => {
    if (value.trim() && !disabled) {
      onSend(value.trim())
      setValue('')
      inputRef.current?.focus()
    }
  }

  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      handleSubmit()
    }
  }

  const handleInput = (e: Event) => {
    const target = e.target as HTMLTextAreaElement
    setValue(target.value)
    target.style.height = 'auto'
    target.style.height = `${Math.min(target.scrollHeight, 120)}px`
  }

  return (
    <div class="chat-input-container">
      <textarea
        ref={inputRef}
        class="chat-input"
        value={value}
        onInput={handleInput}
        onKeyDown={handleKeyDown}
        placeholder={placeholder}
        disabled={disabled}
        rows={1}
      />
      <button
        class="chat-send-button"
        onClick={handleSubmit}
        disabled={disabled || !value.trim()}
        aria-label="Gửi tin nhắn"
      >
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z" />
        </svg>
      </button>
    </div>
  )
}
</file>

<file path="widget/src/components/chat-messages.tsx">
import type { Message } from '../types'
import { ChatBubble } from './chat-bubble'

interface ChatMessagesProps {
  messages: Message[]
  isLoading: boolean
}

export function ChatMessages({ messages, isLoading }: ChatMessagesProps) {
  return (
    <div class="chat-messages">
      {messages.length === 0 && (
        <div class="chat-welcome">
          <div class="chat-welcome-icon">💬</div>
          <p>Xin chào! Tôi có thể giúp gì cho bạn?</p>
        </div>
      )}

      {messages.map(message => (
        <ChatBubble key={message.id} message={message} />
      ))}

      {isLoading && messages[messages.length - 1]?.content === '' && (
        <div class="typing-indicator">
          <span></span>
          <span></span>
          <span></span>
        </div>
      )}
    </div>
  )
}
</file>

<file path="widget/src/components/product-card.tsx">
import type { Product } from '../types'

interface ProductCardProps {
  product: Product
  onAddToCart?: (variantId: string) => void
}

export function ProductCard({ product, onAddToCart }: ProductCardProps) {
  const handleClick = () => {
    window.open(product.productUrl, '_blank', 'noopener,noreferrer')
  }

  const handleAddToCart = (e: Event) => {
    e.stopPropagation()
    onAddToCart?.(product.variantId)
  }

  return (
    <div class="product-card" onClick={handleClick}>
      {product.imageUrl && (
        <div class="product-image">
          <img src={product.imageUrl} alt={product.title} loading="lazy" />
        </div>
      )}
      <div class="product-info">
        <h4 class="product-title">{product.title}</h4>
        {product.description && (
          <p class="product-description">{product.description}</p>
        )}
        <div class="product-footer">
          <span class="product-price">
            {formatPrice(product.price, product.currencyCode)}
          </span>
          {onAddToCart && (
            <button class="product-add-button" onClick={handleAddToCart}>
              Thêm vào giỏ
            </button>
          )}
        </div>
      </div>
    </div>
  )
}

function formatPrice(price: string, currencyCode: string): string {
  const num = parseFloat(price)
  if (isNaN(num)) return price

  try {
    return new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: currencyCode
    }).format(num)
  } catch {
    return `${num.toLocaleString('vi-VN')} ${currencyCode}`
  }
}
</file>

<file path="widget/src/hooks/use-chat.ts">
import { useState, useCallback, useRef } from 'preact/hooks'
import type { Message, Product, SSEMessage } from '../types'

interface UseChatOptions {
  apiUrl: string
  tenantId: string
}

interface UseChatReturn {
  messages: Message[]
  isLoading: boolean
  cartId: string | null
  checkoutUrl: string | null
  sendMessage: (content: string) => Promise<void>
  clearMessages: () => void
}

export function useChat({ apiUrl, tenantId }: UseChatOptions): UseChatReturn {
  const [messages, setMessages] = useState<Message[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const [cartId, setCartId] = useState<string | null>(null)
  const [checkoutUrl, setCheckoutUrl] = useState<string | null>(null)
  const sessionIdRef = useRef<string>(generateSessionId())
  const abortControllerRef = useRef<AbortController | null>(null)

  const sendMessage = useCallback(async (content: string) => {
    if (!content.trim() || isLoading) return

    const userMessage: Message = {
      id: generateId(),
      role: 'user',
      content: content.trim(),
      timestamp: Date.now()
    }

    setMessages(prev => [...prev, userMessage])
    setIsLoading(true)

    const assistantMessageId = generateId()
    setMessages(prev => [...prev, {
      id: assistantMessageId,
      role: 'assistant',
      content: '',
      timestamp: Date.now()
    }])

    try {
      abortControllerRef.current = new AbortController()

      const response = await fetch(`${apiUrl}/api/chat`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          tenantId,
          sessionId: sessionIdRef.current,
          message: content.trim(),
          cartId
        }),
        signal: abortControllerRef.current.signal
      })

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`)
      }

      const reader = response.body?.getReader()
      if (!reader) throw new Error('No response body')

      const decoder = new TextDecoder()
      let buffer = ''
      let fullContent = ''
      let products: Product[] = []

      while (true) {
        const { done, value } = await reader.read()
        if (done) break

        buffer += decoder.decode(value, { stream: true })
        const lines = buffer.split('\n')
        buffer = lines.pop() || ''

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.slice(6)
            if (data === '[DONE]') continue

            try {
              const parsed: SSEMessage = JSON.parse(data)

              switch (parsed.type) {
                case 'text':
                  fullContent += parsed.content || ''
                  setMessages(prev => prev.map(m =>
                    m.id === assistantMessageId
                      ? { ...m, content: fullContent }
                      : m
                  ))
                  break

                case 'products':
                  products = parsed.products || []
                  setMessages(prev => prev.map(m =>
                    m.id === assistantMessageId
                      ? { ...m, products }
                      : m
                  ))
                  break

                case 'cart':
                  if (parsed.cartId) setCartId(parsed.cartId)
                  if (parsed.checkoutUrl) setCheckoutUrl(parsed.checkoutUrl)
                  break

                case 'error':
                  fullContent += `\n\nLỗi: ${parsed.content}`
                  setMessages(prev => prev.map(m =>
                    m.id === assistantMessageId
                      ? { ...m, content: fullContent }
                      : m
                  ))
                  break
              }
            } catch {
              // Skip invalid JSON
            }
          }
        }
      }
    } catch (error) {
      if ((error as Error).name !== 'AbortError') {
        setMessages(prev => prev.map(m =>
          m.id === assistantMessageId
            ? { ...m, content: 'Xin lỗi, đã có lỗi xảy ra. Vui lòng thử lại.' }
            : m
        ))
      }
    } finally {
      setIsLoading(false)
      abortControllerRef.current = null
    }
  }, [apiUrl, tenantId, cartId, isLoading])

  const clearMessages = useCallback(() => {
    setMessages([])
    sessionIdRef.current = generateSessionId()
  }, [])

  return {
    messages,
    isLoading,
    cartId,
    checkoutUrl,
    sendMessage,
    clearMessages
  }
}

function generateId(): string {
  return Math.random().toString(36).substring(2, 11)
}

function generateSessionId(): string {
  return `session_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`
}
</file>

<file path="widget/src/hooks/use-sse.ts">
import { useCallback, useRef } from 'preact/hooks'

interface UseSSEOptions {
  onMessage: (data: string) => void
  onError?: (error: Error) => void
  onDone?: () => void
}

interface UseSSEReturn {
  connect: (url: string, body: unknown) => Promise<void>
  disconnect: () => void
  isConnected: boolean
}

export function useSSE({ onMessage, onError, onDone }: UseSSEOptions): UseSSEReturn {
  const abortControllerRef = useRef<AbortController | null>(null)
  const isConnectedRef = useRef(false)

  const connect = useCallback(async (url: string, body: unknown) => {
    if (isConnectedRef.current) {
      abortControllerRef.current?.abort()
    }

    abortControllerRef.current = new AbortController()
    isConnectedRef.current = true

    try {
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'text/event-stream'
        },
        body: JSON.stringify(body),
        signal: abortControllerRef.current.signal
      })

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`)
      }

      const reader = response.body?.getReader()
      if (!reader) throw new Error('No response body')

      const decoder = new TextDecoder()
      let buffer = ''

      while (true) {
        const { done, value } = await reader.read()
        if (done) break

        buffer += decoder.decode(value, { stream: true })
        const lines = buffer.split('\n')
        buffer = lines.pop() || ''

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.slice(6)
            if (data === '[DONE]') {
              onDone?.()
            } else {
              onMessage(data)
            }
          }
        }
      }

      onDone?.()
    } catch (error) {
      if ((error as Error).name !== 'AbortError') {
        onError?.(error as Error)
      }
    } finally {
      isConnectedRef.current = false
      abortControllerRef.current = null
    }
  }, [onMessage, onError, onDone])

  const disconnect = useCallback(() => {
    abortControllerRef.current?.abort()
    isConnectedRef.current = false
  }, [])

  return {
    connect,
    disconnect,
    isConnected: isConnectedRef.current
  }
}
</file>

<file path="widget/src/main.tsx">
import { render } from 'preact'
import { App } from './app'
import './styles.css'

const params = new URLSearchParams(window.location.search)
const tenantId = params.get('tenant') || ''
const apiUrl = params.get('api') || 'https://smart-chat-bot.workers.dev'

render(<App tenantId={tenantId} apiUrl={apiUrl} />, document.getElementById('app')!)
</file>

<file path="widget/src/styles.css">
:root {
  --primary-color: #2563eb;
  --primary-hover: #1d4ed8;
  --bg-color: #ffffff;
  --bg-secondary: #f8fafc;
  --text-color: #1e293b;
  --text-secondary: #64748b;
  --border-color: #e2e8f0;
  --user-bubble: #2563eb;
  --user-text: #ffffff;
  --assistant-bubble: #f1f5f9;
  --assistant-text: #1e293b;
  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  --radius-sm: 6px;
  --radius-md: 12px;
  --radius-lg: 16px;
}

@media (prefers-color-scheme: dark) {
  :root {
    --bg-color: #0f172a;
    --bg-secondary: #1e293b;
    --text-color: #f1f5f9;
    --text-secondary: #94a3b8;
    --border-color: #334155;
    --assistant-bubble: #1e293b;
    --assistant-text: #f1f5f9;
  }
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body, #app {
  height: 100%;
  width: 100%;
  overflow: hidden;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  font-size: 14px;
  line-height: 1.5;
  color: var(--text-color);
  background: var(--bg-color);
  -webkit-font-smoothing: antialiased;
}

.chat-widget {
  display: flex;
  flex-direction: column;
  height: 100%;
  background: var(--bg-color);
}

/* Header */
.chat-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  background: var(--primary-color);
  color: white;
  flex-shrink: 0;
}

.chat-header-info {
  display: flex;
  align-items: center;
  gap: 12px;
}

.chat-avatar {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
}

.chat-title h1 {
  font-size: 16px;
  font-weight: 600;
  margin: 0;
}

.chat-status {
  font-size: 12px;
  opacity: 0.9;
}

.chat-header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
}

.chat-clear-button {
  background: rgba(255, 255, 255, 0.2);
  border: none;
  border-radius: var(--radius-sm);
  padding: 8px;
  cursor: pointer;
  color: white;
  transition: background 0.2s;
}

.chat-clear-button:hover {
  background: rgba(255, 255, 255, 0.3);
}

/* Body / Messages */
.chat-body {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  background: var(--bg-secondary);
}

.chat-messages {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.chat-welcome {
  text-align: center;
  padding: 40px 20px;
  color: var(--text-secondary);
}

.chat-welcome-icon {
  font-size: 48px;
  margin-bottom: 12px;
}

.chat-welcome p {
  font-size: 16px;
}

/* Bubbles */
.chat-bubble-wrapper {
  display: flex;
  flex-direction: column;
  max-width: 85%;
}

.chat-bubble-wrapper.user {
  align-self: flex-end;
  align-items: flex-end;
}

.chat-bubble-wrapper.assistant {
  align-self: flex-start;
  align-items: flex-start;
}

.chat-bubble {
  padding: 10px 14px;
  border-radius: var(--radius-md);
  word-break: break-word;
  white-space: pre-wrap;
}

.chat-bubble.user {
  background: var(--user-bubble);
  color: var(--user-text);
  border-bottom-right-radius: 4px;
}

.chat-bubble.assistant {
  background: var(--assistant-bubble);
  color: var(--assistant-text);
  border-bottom-left-radius: 4px;
}

.chat-bubble-loading {
  opacity: 0.5;
}

/* Typing Indicator */
.typing-indicator {
  display: flex;
  gap: 4px;
  padding: 12px 16px;
  background: var(--assistant-bubble);
  border-radius: var(--radius-md);
  width: fit-content;
}

.typing-indicator span {
  width: 8px;
  height: 8px;
  background: var(--text-secondary);
  border-radius: 50%;
  animation: typing 1.4s infinite ease-in-out;
}

.typing-indicator span:nth-child(2) {
  animation-delay: 0.2s;
}

.typing-indicator span:nth-child(3) {
  animation-delay: 0.4s;
}

@keyframes typing {
  0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
  30% { transform: translateY(-4px); opacity: 1; }
}

/* Product Cards */
.product-cards {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-top: 8px;
  width: 100%;
}

.product-card {
  display: flex;
  gap: 12px;
  padding: 12px;
  background: var(--bg-color);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-md);
  cursor: pointer;
  transition: box-shadow 0.2s, transform 0.2s;
}

.product-card:hover {
  box-shadow: var(--shadow-md);
  transform: translateY(-1px);
}

.product-image {
  width: 64px;
  height: 64px;
  flex-shrink: 0;
  border-radius: var(--radius-sm);
  overflow: hidden;
  background: var(--bg-secondary);
}

.product-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.product-info {
  flex: 1;
  min-width: 0;
}

.product-title {
  font-size: 14px;
  font-weight: 600;
  margin: 0 0 4px;
  color: var(--text-color);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.product-description {
  font-size: 12px;
  color: var(--text-secondary);
  margin: 0 0 8px;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.product-footer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
}

.product-price {
  font-size: 14px;
  font-weight: 600;
  color: var(--primary-color);
}

.product-add-button {
  padding: 4px 10px;
  font-size: 12px;
  background: var(--primary-color);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: background 0.2s;
}

.product-add-button:hover {
  background: var(--primary-hover);
}

/* Cart Button */
.cart-button {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 12px;
  background: rgba(255, 255, 255, 0.2);
  border: none;
  border-radius: var(--radius-sm);
  color: white;
  font-size: 13px;
  cursor: pointer;
  transition: background 0.2s;
  position: relative;
}

.cart-button:hover {
  background: rgba(255, 255, 255, 0.3);
}

.cart-badge {
  position: absolute;
  top: -4px;
  right: -4px;
  width: 18px;
  height: 18px;
  background: #ef4444;
  border-radius: 50%;
  font-size: 11px;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: center;
}

.cart-text {
  font-weight: 500;
}

/* Footer / Input */
.chat-footer {
  padding: 12px 16px;
  background: var(--bg-color);
  border-top: 1px solid var(--border-color);
  flex-shrink: 0;
}

.chat-input-container {
  display: flex;
  align-items: flex-end;
  gap: 8px;
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-md);
  padding: 8px 12px;
  transition: border-color 0.2s;
}

.chat-input-container:focus-within {
  border-color: var(--primary-color);
}

.chat-input {
  flex: 1;
  border: none;
  background: transparent;
  font-size: 14px;
  line-height: 1.5;
  color: var(--text-color);
  resize: none;
  outline: none;
  min-height: 24px;
  max-height: 120px;
}

.chat-input::placeholder {
  color: var(--text-secondary);
}

.chat-send-button {
  width: 36px;
  height: 36px;
  border: none;
  border-radius: var(--radius-sm);
  background: var(--primary-color);
  color: white;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background 0.2s, opacity 0.2s;
  flex-shrink: 0;
}

.chat-send-button:hover:not(:disabled) {
  background: var(--primary-hover);
}

.chat-send-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Scrollbar */
.chat-body::-webkit-scrollbar {
  width: 6px;
}

.chat-body::-webkit-scrollbar-track {
  background: transparent;
}

.chat-body::-webkit-scrollbar-thumb {
  background: var(--border-color);
  border-radius: 3px;
}

.chat-body::-webkit-scrollbar-thumb:hover {
  background: var(--text-secondary);
}
</file>

<file path="widget/src/types.ts">
export interface Message {
  id: string
  role: 'user' | 'assistant'
  content: string
  products?: Product[]
  timestamp: number
}

export interface Product {
  id: string
  title: string
  description: string
  price: string
  currencyCode: string
  imageUrl: string
  productUrl: string
  variantId: string
}

export interface ChatResponse {
  sessionId: string
  cartId?: string
  checkoutUrl?: string
}

export interface SSEMessage {
  type: 'text' | 'products' | 'cart' | 'error' | 'done'
  content?: string
  products?: Product[]
  cartId?: string
  checkoutUrl?: string
}
</file>

<file path="widget/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "jsxImportSource": "preact",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"]
}
</file>

<file path="widget/vite.config.ts">
import { defineConfig } from 'vite'
import preact from '@preact/preset-vite'

export default defineConfig({
  plugins: [preact()],
  build: {
    outDir: 'dist',
    minify: 'esbuild',
    rollupOptions: {
      output: {
        manualChunks: undefined,
        entryFileNames: 'chat-widget.js',
        assetFileNames: 'chat-widget.[ext]'
      }
    }
  }
})
</file>

<file path="wrangler.toml">
name = "smart-chat-bot"
main = "src/index.ts"
compatibility_date = "2026-02-01"

# Workers configuration
workers_dev = true
minify = true

[vars]
ENVIRONMENT = "production"

# KV namespace for rate limiting (optional)
# Uncomment and set id after creating namespace via:
# wrangler kv:namespace create "RATE_LIMIT"
# [[kv_namespaces]]
# binding = "RATE_LIMIT"
# id = "your-kv-namespace-id"

# Secrets - set via: wrangler secret put <NAME>
# Required secrets:
#   wrangler secret put SUPABASE_URL
#   wrangler secret put SUPABASE_SERVICE_ROLE_KEY
#   wrangler secret put OPENAI_API_KEY
#
# Optional secrets:
#   wrangler secret put CLAUDIBLE_API_KEY

# Production environment
[env.production]
name = "smart-chat-bot"
workers_dev = false

[env.production.vars]
ENVIRONMENT = "production"

# Staging environment (optional)
[env.staging]
name = "smart-chat-bot-staging"
workers_dev = true

[env.staging.vars]
ENVIRONMENT = "staging"
</file>

</files>
